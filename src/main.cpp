/**
 * NB-IoT JamBox Probe Counter Firmware
 *
 * M5Stack AtomS3 DTU-NB-IoT (ESP32-S3 + SIM7028)
 *
 * Captures 802.11 probe requests using WiFi promiscuous mode,
 * counts unique MAC addresses, and reports to backend via NB-IoT.
 *
 * Hardware Configuration:
 *   - GPIO5 = ESP32 TX -> Modem RX
 *   - GPIO6 = ESP32 RX <- Modem TX
 *   - GPIO35 = Built-in RGB LED (WS2812, directly driven)
 *   - GPIO41 = Button
 *
 * LED Status Colors:
 *   - PURPLE: Booting / initializing
 *   - RED (slow blink): Searching for network
 *   - RED (fast blink): Critical error
 *   - GREEN: Connected, counting probes
 *   - CYAN (pulse): Transmitting data
 *   - GREEN (3 sec): Send successful
 *   - BLUE (slow blink): Send failed
 *   - YELLOW (pulse): OTA update mode
 *   - WHITE (flash): Button press acknowledged
 *
 * Backend: http://172.233.144.32:5000/api/reading
 * Auth: Bearer token
 * Payload: {"d":"NB000001","t":TIMESTAMP,"i":IMPRESSIONS,"u":UNIQUE,"sig":SIGNAL}
 *
 * OTA Update:
 *   Backend can trigger OTA mode by including "ota":true in response.
 *   Device will then enter WiFi AP mode for local firmware update.
 */

#include <Arduino.h>
#include <WiFi.h>
#include <esp_wifi.h>
#include <WebServer.h>
#include <Update.h>
#include <FastLED.h>
#include <set>
#include <time.h>

// =============================================================================
// Device Type Classification
// =============================================================================

enum DeviceType { DEVICE_APPLE, DEVICE_ANDROID, DEVICE_OTHER };

// Heuristic detection from randomized MAC patterns
static DeviceType classifyDevice(const uint8_t* mac) {
    uint8_t firstByte = mac[0];
    uint8_t secondNibble = firstByte & 0x0F;

    // Apple randomized MACs commonly use: x2, x6, xA, xE patterns
    if (secondNibble == 0x02 || secondNibble == 0x06 ||
        secondNibble == 0x0A || secondNibble == 0x0E) {
        return DEVICE_APPLE;
    }

    // Android uses more varied patterns - detect by exclusion
    // If it's randomized but not Apple pattern, likely Android
    return DEVICE_ANDROID;
}

// =============================================================================
// Configuration
// =============================================================================

// Include device-specific configuration (generated by NBJBTOOL.sh)
#include "device_config.h"

// Firmware version
static const char* FIRMWARE_VERSION = "2.9";

// SSL Configuration (disabled for now - AT+CCHOPEN failing)
#define USE_SSL false
#define SSL_CTX_INDEX 0  // SSL context index (0-5)

// Timing configuration (milliseconds)
static const uint32_t AT_COMMAND_TIMEOUT_MS = 10000;
static const uint32_t TCP_CONNECT_TIMEOUT_MS = 30000;
static const uint32_t NETWORK_INIT_TIMEOUT_MS = 120000;

// Pin definitions for AtomS3 DTU-NB-IoT
#define MODEM_TX_PIN    5       // ESP32 TX -> Modem RX
#define MODEM_RX_PIN    6       // ESP32 RX <- Modem TX
#define MODEM_BAUD      115200
#define LED_PIN         35      // AtomS3 RGB LED (WS2812)
#define BUTTON_PIN      41      // AtomS3 Main Button (front)
#define RESET_BUTTON_PIN 39     // AtomS3 Side Button (reset/reboot)
#define NUM_LEDS        1       // Single RGB LED

// WiFi channel hopping configuration
// Channels 1, 6, 11 are non-overlapping 2.4GHz channels
static const uint8_t WIFI_CHANNELS[] = {1, 6, 11};
static const uint8_t WIFI_CHANNEL_COUNT = 3;
static const uint32_t CHANNEL_HOP_INTERVAL_MS = 3000;  // 3 seconds per channel

// Maximum unique MACs to track per period (memory constraint)
#define MAX_UNIQUE_MACS 500

// Privacy: Only count randomized MACs (filters out static/PII MACs)
// Randomized MACs have bit 1 of first byte set (locally administered)
// Static MACs are globally unique and considered PII under GDPR/CCPA
#define PRIVACY_FILTER_ENABLED true

// Access point counting (beacons) - disabled by default
static bool g_countAccessPoints = false;

// Maximum unique APs to track
#define MAX_UNIQUE_APS 100

// =============================================================================
// WiFi Geolocation Scan Configuration
// =============================================================================

// Maximum WiFi networks to scan for geolocation
#define MAX_WIFI_NETWORKS 10

// Note: GEOLOCATION_PATH is defined in device_config.h

// WiFi network info for geolocation
struct WifiNetwork {
    char bssid[18];  // "AA:BB:CC:DD:EE:FF" format
    int rssi;
    int channel;
};

static WifiNetwork g_wifiNetworks[MAX_WIFI_NETWORKS];
static int g_wifiNetworkCount = 0;

// =============================================================================
// LED Status Definitions
// =============================================================================

// LED Status states
enum LedStatus {
    LED_STATUS_BOOTING,        // PURPLE - Initializing modem/boot sequence
    LED_STATUS_SEARCHING,      // RED slow blink - Looking for network
    LED_STATUS_ERROR,          // RED fast blink - Critical error (SIM/modem fail)
    LED_STATUS_CONNECTED,      // CYAN solid - Connected, counting, waiting
    LED_STATUS_TRANSMITTING,   // ORANGE flash - Sending data
    LED_STATUS_SEND_SUCCESS,   // GREEN solid (3 sec) - Send successful
    LED_STATUS_SEND_FAILED,    // BLUE slow blink - Connected but send failed
    LED_STATUS_OTA_MODE,       // YELLOW pulsing - WiFi AP for update
    LED_STATUS_BUTTON_ACK      // WHITE flash - Button press acknowledged
};

// LED Colors (GRB order for WS2812)
#define COLOR_OFF       CRGB::Black
#define COLOR_GREEN     CRGB::Green
#define COLOR_RED       CRGB::Red
#define COLOR_BLUE      CRGB::Blue
#define COLOR_YELLOW    CRGB::Yellow
#define COLOR_ORANGE    CRGB::Orange
#define COLOR_PURPLE    CRGB::Purple
#define COLOR_CYAN      CRGB::Cyan
#define COLOR_WHITE     CRGB::White

// =============================================================================
// Global State
// =============================================================================

// FastLED array
CRGB g_leds[NUM_LEDS];

// Current LED status
static LedStatus g_ledStatus = LED_STATUS_SEARCHING;
static uint32_t g_lastLedUpdate = 0;
static bool g_ledBlinkState = false;

// UART for modem
HardwareSerial ModemSerial(1);

// Probe counting state
static volatile uint32_t g_totalProbes = 0;
static volatile uint32_t g_filteredStatic = 0;  // Count of rejected static MACs
static volatile uint32_t g_appleCount = 0;      // Apple device count
static volatile uint32_t g_androidCount = 0;    // Android device count
static volatile uint32_t g_otherCount = 0;      // Other device count (non-Apple, non-Android)
static std::set<uint64_t> g_uniqueMacs;
static std::set<uint64_t> g_uniqueAPs;          // Unique access points (BSSIDs)
static portMUX_TYPE g_probeMux = portMUX_INITIALIZER_UNLOCKED;

// Probe RSSI tracking (WiFi signal strength from phones)
static volatile int32_t g_probeRssiSum = 0;
static volatile int32_t g_probeRssiMin = 0;      // Min RSSI (closest device)
static volatile int32_t g_probeRssiMax = -999;   // Max RSSI (farthest device)
static volatile uint32_t g_probeRssiCount = 0;

// Timing
static uint32_t g_lastReportTime = 0;
static uint32_t g_lastHeartbeatTime = 0;
static uint32_t g_bootTimestamp = 0;  // Pseudo-timestamp from boot

// Channel hopping state
static uint8_t g_currentChannelIndex = 0;
static uint32_t g_lastChannelHop = 0;

// Cached reading for retry
struct CachedReading {
    bool valid;
    char timestamp[25];
    uint32_t impressions;
    uint32_t unique;
    uint32_t apple;
    uint32_t android;
    uint32_t other;
    int probeRssiAvg;
    int probeRssiMin;
    int probeRssiMax;
    int cellRssi;
};
static CachedReading g_cachedReading = {false, "", 0, 0, 0, 0, 0, 0, 0, 0, 0};

// Network state
static bool g_networkReady = false;
static int g_cellRssi = 0;          // Cellular signal strength (dBm)
static bool g_lastSendSuccess = false;

// Geolocation state - flag to send once network connects
static bool g_geolocationPending = false;

// OTA state
static bool g_otaRequested = false;
static bool g_otaInProgress = false;
static WebServer* g_otaServer = nullptr;

// Button state
static bool g_forceSendRequested = false;

// AT response buffer
static char g_atBuffer[512];
static size_t g_atBufferLen = 0;

// =============================================================================
// LED Control Functions
// =============================================================================

static void ledInit() {
    FastLED.addLeds<WS2812, LED_PIN, GRB>(g_leds, NUM_LEDS);
    FastLED.setBrightness(50);  // Moderate brightness to save power
    g_leds[0] = COLOR_OFF;
    FastLED.show();
}

static void ledSetColor(CRGB color) {
    g_leds[0] = color;
    FastLED.show();
}

static void ledSetStatus(LedStatus status) {
    g_ledStatus = status;
    g_lastLedUpdate = millis();
    g_ledBlinkState = true;

    // Set initial color based on status
    switch (status) {
        case LED_STATUS_BOOTING:
            ledSetColor(COLOR_PURPLE);
            break;
        case LED_STATUS_SEARCHING:
            ledSetColor(COLOR_RED);
            break;
        case LED_STATUS_ERROR:
            ledSetColor(COLOR_RED);
            break;
        case LED_STATUS_CONNECTED:
            ledSetColor(COLOR_GREEN);
            break;
        case LED_STATUS_TRANSMITTING:
            ledSetColor(COLOR_CYAN);
            break;
        case LED_STATUS_SEND_SUCCESS:
            ledSetColor(COLOR_GREEN);
            break;
        case LED_STATUS_SEND_FAILED:
            ledSetColor(COLOR_BLUE);
            break;
        case LED_STATUS_OTA_MODE:
            ledSetColor(COLOR_YELLOW);
            break;
        case LED_STATUS_BUTTON_ACK:
            ledSetColor(COLOR_WHITE);
            break;
    }
}

// Update LED animation (call from loop)
static void ledUpdate() {
    uint32_t now = millis();
    uint32_t elapsed = now - g_lastLedUpdate;

    switch (g_ledStatus) {
        case LED_STATUS_BOOTING:
            // Solid purple - no animation
            break;

        case LED_STATUS_SEARCHING:
            // Slow blink red (500ms on, 500ms off)
            if (elapsed >= 500) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_RED : COLOR_OFF);
            }
            break;

        case LED_STATUS_ERROR:
            // Fast blink red (100ms on, 100ms off)
            if (elapsed >= 100) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_RED : COLOR_OFF);
            }
            break;

        case LED_STATUS_CONNECTED:
            // Solid cyan with brief dim every 2s to show alive
            if (elapsed >= 2000) {
                g_lastLedUpdate = now;
                FastLED.setBrightness(20);
                FastLED.show();
                delay(50);
                FastLED.setBrightness(50);
                FastLED.show();
            }
            break;

        case LED_STATUS_TRANSMITTING:
            // Fast pulse cyan
            if (elapsed >= 150) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_CYAN : COLOR_OFF);
            }
            break;

        case LED_STATUS_SEND_SUCCESS:
            // Solid green for 3 seconds, then return to connected
            if (elapsed >= 3000) {
                ledSetStatus(LED_STATUS_CONNECTED);
            }
            break;

        case LED_STATUS_SEND_FAILED:
            // Slow blink blue (1s on, 1s off)
            if (elapsed >= 1000) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_BLUE : COLOR_OFF);
            }
            break;

        case LED_STATUS_OTA_MODE:
            // Fast pulse yellow
            if (elapsed >= 200) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_YELLOW : COLOR_ORANGE);
            }
            break;

        case LED_STATUS_BUTTON_ACK:
            // White flash, then return to previous state
            if (elapsed >= 200) {
                ledSetStatus(g_networkReady ? LED_STATUS_CONNECTED : LED_STATUS_SEARCHING);
            }
            break;
    }
}

// Brief flash for activity indication (non-blocking setup)
static void ledFlash(CRGB color, int count, int onMs) {
    for (int i = 0; i < count; i++) {
        ledSetColor(color);
        delay(onMs);
        ledSetColor(COLOR_OFF);
        if (i < count - 1) delay(onMs);
    }
    // Restore status color
    ledSetStatus(g_ledStatus);
}

// =============================================================================
// WiFi Promiscuous Mode - Probe Request Capture
// =============================================================================

// 802.11 frame type definitions
#define WIFI_MGMT_FRAME     0
#define WIFI_PROBE_REQUEST  4
#define WIFI_BEACON         8

// Check if MAC address is randomized (locally administered)
// Bit 1 of first byte: 0 = globally unique (static), 1 = locally administered (randomized)
static inline bool isRandomizedMac(const uint8_t* mac) {
    return (mac[0] & 0x02) != 0;
}

// WiFi promiscuous callback - called from WiFi task context
static void IRAM_ATTR wifiProbeCounterCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
    if (type != WIFI_PKT_MGMT) return;

    const wifi_promiscuous_pkt_t* pkt = (wifi_promiscuous_pkt_t*)buf;
    const uint8_t* frame = pkt->payload;
    const int len = pkt->rx_ctrl.sig_len;

    // Need at least frame control + duration + 3 addresses (24 bytes)
    if (len < 24) return;

    // Frame control field (first 2 bytes)
    uint8_t frameType = (frame[0] >> 2) & 0x03;     // bits 2-3
    uint8_t frameSubtype = (frame[0] >> 4) & 0x0F;  // bits 4-7

    // Only process management frames
    if (frameType != WIFI_MGMT_FRAME) return;

    // Handle beacon frames (access point counting)
    if (frameSubtype == WIFI_BEACON && g_countAccessPoints) {
        // BSSID is at bytes 16-21 in beacon frame
        const uint8_t* bssid = &frame[16];
        uint64_t bssidVal = 0;
        for (int i = 0; i < 6; i++) {
            bssidVal = (bssidVal << 8) | bssid[i];
        }

        portENTER_CRITICAL(&g_probeMux);
        if (g_uniqueAPs.size() < MAX_UNIQUE_APS) {
            g_uniqueAPs.insert(bssidVal);
        }
        portEXIT_CRITICAL(&g_probeMux);
        return;
    }

    // Filter for probe requests only (subtype=4)
    if (frameSubtype != WIFI_PROBE_REQUEST) return;

    // Extract source MAC address (bytes 10-15 in 802.11 header)
    // Header: FC(2) + Duration(2) + DA(6) + SA(6) + BSSID(6) + SeqCtrl(2)
    const uint8_t* srcMac = &frame[10];

    // Privacy filter: Only count randomized MACs
    // Static MACs are globally unique (PII) - we reject them
#if PRIVACY_FILTER_ENABLED
    if (!isRandomizedMac(srcMac)) {
        portENTER_CRITICAL(&g_probeMux);
        g_filteredStatic++;
        portEXIT_CRITICAL(&g_probeMux);
        return;
    }
#endif

    // Classify device type (Apple vs Android)
    DeviceType deviceType = classifyDevice(srcMac);

    // Convert MAC to uint64_t for set storage
    uint64_t macVal = 0;
    for (int i = 0; i < 6; i++) {
        macVal = (macVal << 8) | srcMac[i];
    }

    // Create dedup key: MAC (48 bits) + current minute (16 bits)
    // This counts each device once per minute (MRC "opportunity to see" standard)
    uint32_t currentMinute = millis() / 60000;
    uint64_t dedupKey = macVal | ((uint64_t)(currentMinute & 0xFFFF) << 48);

    // Capture probe RSSI (WiFi signal strength from the phone)
    int probeRssi = pkt->rx_ctrl.rssi;

    // Update counters with mutex protection
    portENTER_CRITICAL(&g_probeMux);
    g_totalProbes++;
    if (g_uniqueMacs.size() < MAX_UNIQUE_MACS) {
        g_uniqueMacs.insert(dedupKey);  // Dedupes per MAC per minute
    }
    // Count by device type
    if (deviceType == DEVICE_APPLE) {
        g_appleCount++;
    } else if (deviceType == DEVICE_ANDROID) {
        g_androidCount++;
    } else {
        g_otherCount++;
    }
    // Track probe RSSI stats
    g_probeRssiSum += probeRssi;
    g_probeRssiCount++;
    if (probeRssi < g_probeRssiMin || g_probeRssiMin == 0) {
        g_probeRssiMin = probeRssi;
    }
    if (probeRssi > g_probeRssiMax) {
        g_probeRssiMax = probeRssi;
    }
    portEXIT_CRITICAL(&g_probeMux);
}

static void startProbeCapture() {
    Serial.println("[PROBE] Starting WiFi promiscuous mode...");

    // Initialize WiFi in station mode first
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    delay(100);

    // Initialize channel hopping state
    g_currentChannelIndex = 0;
    g_lastChannelHop = millis();
    esp_wifi_set_channel(WIFI_CHANNELS[g_currentChannelIndex], WIFI_SECOND_CHAN_NONE);

    // Configure promiscuous filter for management frames only
    wifi_promiscuous_filter_t filter = {
        .filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT
    };
    esp_wifi_set_promiscuous_filter(&filter);

    // Register callback and enable promiscuous mode
    esp_wifi_set_promiscuous_rx_cb(&wifiProbeCounterCallback);
    esp_wifi_set_promiscuous(true);

    Serial.printf("[PROBE] Channel hopping enabled: 1, 6, 11 (3s interval)\n");
    Serial.printf("[PROBE] Starting on channel %d\n", WIFI_CHANNELS[g_currentChannelIndex]);
}

static void stopProbeCapture() {
    esp_wifi_set_promiscuous(false);
    Serial.println("[PROBE] Promiscuous mode stopped");
}

// Channel hopping - call from main loop
static void updateChannelHop() {
    uint32_t now = millis();
    if ((now - g_lastChannelHop) >= CHANNEL_HOP_INTERVAL_MS) {
        g_lastChannelHop = now;
        g_currentChannelIndex = (g_currentChannelIndex + 1) % WIFI_CHANNEL_COUNT;
        esp_wifi_set_channel(WIFI_CHANNELS[g_currentChannelIndex], WIFI_SECOND_CHAN_NONE);
    }
}

// =============================================================================
// AT Command Interface
// =============================================================================

// Clear the AT response buffer
static void atClearBuffer() {
    g_atBufferLen = 0;
    g_atBuffer[0] = '\0';
}

// Send AT command and wait for response
// Returns true if expected response found, false on timeout
static bool atSendCommand(const char* cmd, const char* expect, uint32_t timeoutMs) {
    atClearBuffer();

    // Flush any pending input
    while (ModemSerial.available()) {
        ModemSerial.read();
    }

    // Send command
    Serial.printf("[AT TX] %s\n", cmd);
    ModemSerial.print(cmd);
    ModemSerial.print("\r\n");

    uint32_t startTime = millis();
    bool found = false;

    while ((millis() - startTime) < timeoutMs && !found) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
            g_atBuffer[g_atBufferLen] = '\0';

            // Check for expected response
            if (expect && strstr(g_atBuffer, expect)) {
                found = true;
                break;
            }

            // Check for error
            if (strstr(g_atBuffer, "ERROR")) {
                Serial.printf("[AT RX] %s\n", g_atBuffer);
                return false;
            }
        }
        delay(10);
    }

    Serial.printf("[AT RX] %s\n", g_atBuffer);
    return found;
}

// Send raw data (for TCP payload)
static void atSendRaw(const char* data, size_t len) {
    Serial.printf("[AT TX RAW] (%zu bytes)\n", len);
    ModemSerial.write((const uint8_t*)data, len);
}

// Wait for specific string in modem output
static bool atWaitFor(const char* expect, uint32_t timeoutMs) {
    atClearBuffer();
    uint32_t startTime = millis();

    while ((millis() - startTime) < timeoutMs) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
            g_atBuffer[g_atBufferLen] = '\0';

            if (strstr(g_atBuffer, expect)) {
                Serial.printf("[AT RX] %s\n", g_atBuffer);
                return true;
            }
        }
        delay(10);
    }

    Serial.printf("[AT RX TIMEOUT] %s\n", g_atBuffer);
    return false;
}

// =============================================================================
// Modem & Network Management
// =============================================================================

// Get signal quality (CSQ) and convert to dBm
static int getSignalQuality() {
    // AT Command: AT+CSQ
    // Purpose: Query signal quality
    // Expected Response: +CSQ: <rssi>,<ber>\r\nOK
    // Timeout: 5000ms
    // Reference: SIM7028 AT Command Manual Section 5.3
    //
    // Note: Must wait for "OK" to ensure complete response is received.
    // The SIM7028 sends "+CSQ: XX,YY" followed by "\r\nOK" and we need
    // the full response to parse the rssi value correctly.

    if (!atSendCommand("AT+CSQ", "OK", 5000)) {
        Serial.println("[NET] CSQ command failed or timed out");
        return -999;
    }

    // Parse +CSQ: rssi,ber from buffer
    // Response format: "+CSQ: 15,99" or "+CSQ:15,99" (with or without space)
    char* ptr = strstr(g_atBuffer, "+CSQ:");
    if (!ptr) {
        Serial.println("[NET] CSQ response not found in buffer");
        return -999;
    }

    int rssi = 99;
    int ber = 99;

    // Try parsing with space first, then without
    if (sscanf(ptr, "+CSQ: %d,%d", &rssi, &ber) != 2) {
        if (sscanf(ptr, "+CSQ:%d,%d", &rssi, &ber) != 2) {
            Serial.printf("[NET] Failed to parse CSQ response: %s\n", ptr);
            return -999;
        }
    }

    Serial.printf("[NET] CSQ raw: rssi=%d, ber=%d\n", rssi, ber);

    // Convert RSSI to dBm
    // 0 = -113 dBm or less
    // 1 = -111 dBm
    // 2-30 = -109 to -53 dBm (2 dBm steps)
    // 31 = -51 dBm or greater
    // 99 = not known or not detectable
    if (rssi == 99) return -999;
    if (rssi == 0) return -113;
    if (rssi == 31) return -51;
    return -113 + (rssi * 2);
}

// Check network registration status
static bool checkNetworkRegistration() {
    // AT Command: AT+CEREG?
    // Purpose: Query EPS network registration status
    // Expected Response: +CEREG: <n>,<stat>\r\nOK
    // Timeout: 5000ms
    // Reference: SIM7028 AT Command Manual Section 7.2

    // Wait for OK (end of response) to ensure we have complete data
    if (!atSendCommand("AT+CEREG?", "OK", 5000)) {
        return false;
    }

    // Parse +CEREG: n,stat from buffer
    char* ptr = strstr(g_atBuffer, "+CEREG:");
    if (!ptr) return false;

    int n = 0, stat = 0;
    // Try parsing with both spaces and without
    if (sscanf(ptr, "+CEREG: %d,%d", &n, &stat) != 2) {
        if (sscanf(ptr, "+CEREG:%d,%d", &n, &stat) != 2) {
            Serial.printf("[NET] Failed to parse CEREG: %s\n", ptr);
            return false;
        }
    }

    Serial.printf("[NET] CEREG status: n=%d, stat=%d\n", n, stat);

    // stat: 1=registered home, 5=registered roaming
    return (stat == 1 || stat == 5);
}

// Initialize modem and establish network connection
static bool initializeNetwork() {
    Serial.println("[NET] Initializing modem...");
    ledSetStatus(LED_STATUS_SEARCHING);

    // Basic modem test with retry loop
    // Modem needs time to initialize after power-on
    bool modemReady = false;
    for (int attempt = 1; attempt <= 5; attempt++) {
        Serial.printf("[NET] Modem AT test attempt %d/5...\n", attempt);
        if (atSendCommand("AT", "OK", 2000)) {
            modemReady = true;
            break;
        }
        Serial.println("[NET] Modem not ready, waiting 2 seconds...");
        delay(2000);
    }

    if (!modemReady) {
        Serial.println("[NET] Modem not responding after 5 attempts");
        ledSetStatus(LED_STATUS_ERROR);
        return false;
    }

    // Disable echo
    // AT Command: ATE0
    // Purpose: Disable command echo
    // Expected Response: OK
    // Timeout: 2000ms
    atSendCommand("ATE0", "OK", 2000);

    // Check SIM status
    // AT Command: AT+CPIN?
    // Purpose: Check SIM card status
    // Expected Response: +CPIN: READY
    // Timeout: 5000ms
    if (!atSendCommand("AT+CPIN?", "READY", 5000)) {
        Serial.println("[NET] SIM not ready");
        ledSetStatus(LED_STATUS_ERROR);
        return false;
    }

    // Set NB-IoT only mode
    // AT Command: AT+CNMP=38
    // Purpose: Set preferred network mode to NB-IoT only
    // Expected Response: OK
    // Timeout: 5000ms
    atSendCommand("AT+CNMP=38", "OK", 5000);

    // Wait for network registration
    Serial.println("[NET] Waiting for network registration...");
    uint32_t startTime = millis();
    while ((millis() - startTime) < NETWORK_INIT_TIMEOUT_MS) {
        ledUpdate();  // Keep LED animation running
        if (checkNetworkRegistration()) {
            Serial.println("[NET] Registered to network");
            break;
        }
        Serial.print(".");
        delay(5000);
    }

    if (!checkNetworkRegistration()) {
        Serial.println("\n[NET] Registration timeout");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    // Get signal quality
    g_cellRssi = getSignalQuality();
    Serial.printf("[NET] Signal: %d dBm\n", g_cellRssi);

    // Close any existing network connection
    // AT Command: AT+NETCLOSE
    // Purpose: Close network connection to clean state
    // Expected Response: OK or +NETCLOSE
    // Timeout: 5000ms
    atSendCommand("AT+NETCLOSE", "OK", 5000);
    delay(1000);

    // Configure PDP context with Hologram APN
    // AT Command: AT+CGDCONT=0,"IP","hologram"
    // Purpose: Define PDP context 0 with Hologram APN
    // Expected Response: OK
    // Timeout: 5000ms
    atSendCommand("AT+CGDCONT=0,\"IP\",\"hologram\"", "OK", 5000);

    // Attach to packet domain
    // AT Command: AT+CGATT=1
    // Purpose: Attach to PS domain
    // Expected Response: OK
    // Timeout: 30000ms
    if (!atSendCommand("AT+CGATT=1", "OK", 30000)) {
        Serial.println("[NET] PS attach failed");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    // Open network connection
    // AT Command: AT+NETOPEN
    // Purpose: Open IP network connection
    // Expected Response: +NETOPEN: 0
    // Timeout: 60000ms
    // Note: This is CRITICAL - registration alone does not enable data
    if (!atSendCommand("AT+NETOPEN", "+NETOPEN: 0", 60000)) {
        // Check if already open
        if (!strstr(g_atBuffer, "Network is already opened")) {
            Serial.println("[NET] NETOPEN failed");
            ledSetStatus(LED_STATUS_SEARCHING);
            return false;
        }
    }

    // Verify IP address
    // AT Command: AT+IPADDR
    // Purpose: Query assigned IP address
    // Expected Response: +IPADDR: x.x.x.x\r\nOK
    // Timeout: 5000ms
    if (!atSendCommand("AT+IPADDR", "OK", 5000)) {
        Serial.println("[NET] No IP address assigned");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    // Make sure we actually got an IP (not an error)
    if (!strstr(g_atBuffer, "+IPADDR:")) {
        Serial.println("[NET] IPADDR response missing");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    Serial.println("[NET] Network ready");
    g_networkReady = true;
    ledSetStatus(LED_STATUS_CONNECTED);  // Set LED to CYAN when network is ready
    return true;
}

// =============================================================================
// HTTP POST via TCP
// =============================================================================

// Check response for OTA trigger flag
static bool checkOtaTrigger(const char* response) {
    // Look for "ota":true or "ota": true in JSON response
    return (strstr(response, "\"ota\":true") != NULL ||
            strstr(response, "\"ota\": true") != NULL);
}

// Send reading to backend via HTTP POST over TCP
static bool sendReading(const char* timestamp, uint32_t impressions, uint32_t unique,
                        uint32_t apple, uint32_t android, uint32_t other,
                        int probeRssiAvg, int probeRssiMin, int probeRssiMax, int cellRssi) {
    Serial.printf("[HTTP] Sending: t=%s, i=%lu, u=%lu, apple=%lu, android=%lu, other=%lu\n",
                  timestamp, impressions, unique, apple, android, other);
    Serial.printf("[HTTP]   probe_rssi: avg=%d min=%d max=%d, cell_rssi=%d\n",
                  probeRssiAvg, probeRssiMin, probeRssiMax, cellRssi);

    ledSetStatus(LED_STATUS_TRANSMITTING);  // Orange pulsing during send

    // Build JSON payload with device type breakdown and dual signal tracking
    char jsonPayload[300];
    snprintf(jsonPayload, sizeof(jsonPayload),
             "{\"d\":\"%s\",\"t\":\"%s\",\"i\":%lu,\"u\":%lu,\"apple\":%lu,\"android\":%lu,\"other\":%lu,"
             "\"probe_rssi_avg\":%d,\"probe_rssi_min\":%d,\"probe_rssi_max\":%d,\"cell_rssi\":%d}",
             DEVICE_ID, timestamp, impressions, unique, apple, android, other,
             probeRssiAvg, probeRssiMin, probeRssiMax, cellRssi);

    size_t jsonLen = strlen(jsonPayload);

    // Build HTTP request
    char httpRequest[512];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        BACKEND_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    Serial.printf("[HTTP] Connecting to %s:%d\n", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[HTTP] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        g_lastSendSuccess = false;
        ledSetStatus(LED_STATUS_SEND_FAILED);
        return false;
    }

    Serial.println("[HTTP] Connected");
    delay(500);

    // Send data
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[HTTP] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        g_lastSendSuccess = false;
        ledSetStatus(LED_STATUS_SEND_FAILED);
        return false;
    }

    // Send HTTP request data
    atSendRaw(httpRequest, httpLen);

    // Wait for send confirmation
    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[HTTP] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        g_lastSendSuccess = false;
        ledSetStatus(LED_STATUS_SEND_FAILED);
        return false;
    }

    // Wait for HTTP response
    delay(2000);

    // Read response data
    atClearBuffer();
    uint32_t readStart = millis();
    while ((millis() - readStart) < 5000) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(100);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    if (g_atBufferLen > 0) {
        Serial.printf("[HTTP] Response: %s\n", g_atBuffer);
    }

    // Check for HTTP success (200 OK or 201 Created)
    bool success = (strstr(g_atBuffer, "200") != NULL ||
                    strstr(g_atBuffer, "201") != NULL);

    // Check for OTA trigger in response
    if (success && checkOtaTrigger(g_atBuffer)) {
        Serial.println("[HTTPS] OTA update requested by backend");
        g_otaRequested = true;
    }

    // Close TCP connection
    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    if (success) {
        Serial.println("[HTTP] Success");
        g_lastSendSuccess = true;
        ledSetStatus(LED_STATUS_SEND_SUCCESS);  // Green for 3 sec, then cyan
    } else {
        Serial.println("[HTTP] Response not OK");
        g_lastSendSuccess = false;
        ledSetStatus(LED_STATUS_SEND_FAILED);   // Blue slow blink
    }

    return success;
}

// =============================================================================
// Heartbeat Function
// =============================================================================

// Send heartbeat to backend - daily check-in even with zero traffic
static bool sendHeartbeat() {
    Serial.println("[HEARTBEAT] Sending heartbeat...");

    // Get current cellular signal
    int cellRssi = getSignalQuality();
    uint32_t uptimeSec = millis() / 1000;

    Serial.printf("[HEARTBEAT] Device: %s, Version: %s, Uptime: %lu sec, RSSI: %d dBm\n",
                  DEVICE_ID, FIRMWARE_VERSION, uptimeSec, cellRssi);

    // Build JSON payload
    // Format: {"d":"JBNB0001","v":"2.8","uptime":86400,"cell_rssi":-85}
    char jsonPayload[128];
    snprintf(jsonPayload, sizeof(jsonPayload),
             "{\"d\":\"%s\",\"v\":\"%s\",\"uptime\":%lu,\"cell_rssi\":%d}",
             DEVICE_ID, FIRMWARE_VERSION, uptimeSec, cellRssi);

    size_t jsonLen = strlen(jsonPayload);

    // Build HTTP request
    char httpRequest[384];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        HEARTBEAT_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    Serial.printf("[HEARTBEAT] Connecting to %s:%d\n", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[HEARTBEAT] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    Serial.println("[HEARTBEAT] Connected");
    delay(500);

    // Send data
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[HEARTBEAT] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Send HTTP request data
    atSendRaw(httpRequest, httpLen);

    // Wait for send confirmation
    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[HEARTBEAT] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Wait for HTTP response
    delay(2000);

    // Read response data
    atClearBuffer();
    uint32_t readStart = millis();
    while ((millis() - readStart) < 5000) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(100);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    if (g_atBufferLen > 0) {
        Serial.printf("[HEARTBEAT] Response: %s\n", g_atBuffer);
    }

    // Check for HTTP success
    bool success = (strstr(g_atBuffer, "200") != NULL ||
                    strstr(g_atBuffer, "201") != NULL);

    // Close TCP connection
    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    if (success) {
        Serial.println("[HEARTBEAT] Success");
    } else {
        Serial.println("[HEARTBEAT] Failed");
    }

    return success;
}

// =============================================================================
// OTA Update via WiFi AP Mode
// =============================================================================

// HTML page for OTA update
static const char* OTA_HTML = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>JamBox OTA Update</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; background: #1a1a2e; color: #eee; }
        h1 { color: #16c60c; }
        .container { max-width: 400px; margin: 0 auto; padding: 20px; background: #16213e; border-radius: 10px; }
        input[type="file"] { margin: 20px 0; }
        input[type="submit"] { background: #16c60c; color: #000; padding: 15px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; }
        input[type="submit"]:hover { background: #13a80a; }
        #progress { width: 100%; height: 30px; margin-top: 20px; display: none; }
        .status { margin-top: 20px; padding: 10px; border-radius: 5px; }
        .success { background: #16c60c; color: #000; }
        .error { background: #f03a47; }
    </style>
</head>
<body>
    <div class="container">
        <h1>JamBox OTA Update</h1>
        <p>Device ID: %DEVICE_ID%</p>
        <form method="POST" action="/update" enctype="multipart/form-data" id="upload_form">
            <input type="file" name="firmware" accept=".bin" required>
            <br><br>
            <input type="submit" value="Upload Firmware">
        </form>
        <progress id="progress" max="100" value="0"></progress>
        <div id="status" class="status" style="display:none;"></div>
    </div>
    <script>
        var form = document.getElementById('upload_form');
        var progress = document.getElementById('progress');
        var status = document.getElementById('status');
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            var data = new FormData(form);
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/update', true);
            progress.style.display = 'block';
            xhr.upload.addEventListener('progress', function(evt) {
                if (evt.lengthComputable) {
                    progress.value = Math.round((evt.loaded / evt.total) * 100);
                }
            });
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    status.style.display = 'block';
                    if (xhr.status == 200) {
                        status.className = 'status success';
                        status.innerHTML = 'Update successful! Rebooting...';
                        setTimeout(function() { location.reload(); }, 5000);
                    } else {
                        status.className = 'status error';
                        status.innerHTML = 'Update failed: ' + xhr.responseText;
                    }
                }
            };
            xhr.send(data);
        });
    </script>
</body>
</html>
)rawliteral";

static void handleOtaRoot() {
    String html = OTA_HTML;
    html.replace("%DEVICE_ID%", DEVICE_ID);
    g_otaServer->send(200, "text/html", html);
}

static void handleOtaUpdate() {
    g_otaServer->sendHeader("Connection", "close");
    if (Update.hasError()) {
        g_otaServer->send(500, "text/plain", "Update failed");
    } else {
        g_otaServer->send(200, "text/plain", "Update successful");
        delay(1000);
        ESP.restart();
    }
}

static void handleOtaUpload() {
    HTTPUpload& upload = g_otaServer->upload();

    if (upload.status == UPLOAD_FILE_START) {
        Serial.printf("[OTA] Update start: %s\n", upload.filename.c_str());
        if (!Update.begin(UPDATE_SIZE_UNKNOWN)) {
            Update.printError(Serial);
        }
    } else if (upload.status == UPLOAD_FILE_WRITE) {
        if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {
            Update.printError(Serial);
        }
    } else if (upload.status == UPLOAD_FILE_END) {
        if (Update.end(true)) {
            Serial.printf("[OTA] Update success: %u bytes\n", upload.totalSize);
        } else {
            Update.printError(Serial);
        }
    }
}

static void startOtaMode() {
    Serial.println("[OTA] Entering OTA update mode...");
    ledSetStatus(LED_STATUS_OTA_MODE);
    g_otaInProgress = true;

    // Stop probe capture
    stopProbeCapture();

    // Stop WiFi promiscuous mode and switch to AP mode
    esp_wifi_set_promiscuous(false);
    WiFi.mode(WIFI_AP);
    WiFi.softAP(OTA_AP_SSID, OTA_AP_PASSWORD);

    IPAddress ip = WiFi.softAPIP();
    Serial.printf("[OTA] AP Started - SSID: %s, Password: %s\n", OTA_AP_SSID, OTA_AP_PASSWORD);
    Serial.printf("[OTA] Connect and browse to http://%s\n", ip.toString().c_str());

    // Start web server for OTA
    g_otaServer = new WebServer(80);
    g_otaServer->on("/", HTTP_GET, handleOtaRoot);
    g_otaServer->on("/update", HTTP_POST, handleOtaUpdate, handleOtaUpload);
    g_otaServer->begin();

    Serial.println("[OTA] Web server started. Waiting for firmware upload...");
}

static void stopOtaMode() {
    Serial.println("[OTA] Exiting OTA mode...");

    if (g_otaServer) {
        g_otaServer->stop();
        delete g_otaServer;
        g_otaServer = nullptr;
    }

    WiFi.softAPdisconnect(true);
    g_otaInProgress = false;
    g_otaRequested = false;

    // Restart probe capture
    startProbeCapture();

    // Restore network status LED
    if (g_networkReady) {
        ledSetStatus(g_lastSendSuccess ? LED_STATUS_CONNECTED : LED_STATUS_SEND_FAILED);
    } else {
        ledSetStatus(LED_STATUS_SEARCHING);
    }
}

// =============================================================================
// Reporting Logic
// =============================================================================

// Get current counts and reset
static void getAndResetCounts(uint32_t* impressions, uint32_t* unique,
                               uint32_t* apple, uint32_t* android, uint32_t* other,
                               int* probeRssiAvg, int* probeRssiMin, int* probeRssiMax) {
    portENTER_CRITICAL(&g_probeMux);
    *impressions = g_totalProbes;
    *unique = g_uniqueMacs.size();
    *apple = g_appleCount;
    *android = g_androidCount;
    *other = g_otherCount;
    // Calculate probe RSSI stats
    if (g_probeRssiCount > 0) {
        *probeRssiAvg = g_probeRssiSum / (int32_t)g_probeRssiCount;
        *probeRssiMin = g_probeRssiMin;
        *probeRssiMax = g_probeRssiMax;
    } else {
        *probeRssiAvg = 0;
        *probeRssiMin = 0;
        *probeRssiMax = 0;
    }
    // Reset all counters
    g_totalProbes = 0;
    g_appleCount = 0;
    g_androidCount = 0;
    g_otherCount = 0;
    g_filteredStatic = 0;
    g_probeRssiSum = 0;
    g_probeRssiMin = 0;
    g_probeRssiMax = -999;
    g_probeRssiCount = 0;
    g_uniqueMacs.clear();
    g_uniqueAPs.clear();
    portEXIT_CRITICAL(&g_probeMux);
}

// Report counts to backend
static void reportCounts() {
    uint32_t impressions, unique, apple, android, other;
    int probeRssiAvg, probeRssiMin, probeRssiMax;
    getAndResetCounts(&impressions, &unique, &apple, &android, &other,
                      &probeRssiAvg, &probeRssiMin, &probeRssiMax);

    // Get current cellular signal
    g_cellRssi = getSignalQuality();

    // Generate ISO 8601 timestamp
    uint32_t epochTime = g_bootTimestamp + (millis() / 1000);
    char timestamp[25];
    time_t rawtime = (time_t)epochTime;
    struct tm* timeinfo = gmtime(&rawtime);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%dT%H:%M:%SZ", timeinfo);

    Serial.printf("[REPORT] Period: %lu probes, %lu unique (Apple:%lu Android:%lu Other:%lu)\n",
                  impressions, unique, apple, android, other);
    Serial.printf("[REPORT] Probe RSSI: avg=%d min=%d max=%d, Cell RSSI: %d dBm\n",
                  probeRssiAvg, probeRssiMin, probeRssiMax, g_cellRssi);

    // Try to send cached reading first (if any)
    if (g_cachedReading.valid) {
        Serial.println("[REPORT] Retrying cached reading...");
        if (sendReading(g_cachedReading.timestamp,
                        g_cachedReading.impressions,
                        g_cachedReading.unique,
                        g_cachedReading.apple,
                        g_cachedReading.android,
                        g_cachedReading.other,
                        g_cachedReading.probeRssiAvg,
                        g_cachedReading.probeRssiMin,
                        g_cachedReading.probeRssiMax,
                        g_cachedReading.cellRssi)) {
            g_cachedReading.valid = false;
            Serial.println("[REPORT] Cached reading sent successfully");
        }
    }

    // Send current reading
    if (!sendReading(timestamp, impressions, unique, apple, android, other,
                     probeRssiAvg, probeRssiMin, probeRssiMax, g_cellRssi)) {
        // Cache for retry
        Serial.println("[REPORT] Caching reading for retry");
        g_cachedReading.valid = true;
        strncpy(g_cachedReading.timestamp, timestamp, sizeof(g_cachedReading.timestamp));
        g_cachedReading.impressions = impressions;
        g_cachedReading.unique = unique;
        g_cachedReading.apple = apple;
        g_cachedReading.android = android;
        g_cachedReading.other = other;
        g_cachedReading.probeRssiAvg = probeRssiAvg;
        g_cachedReading.probeRssiMin = probeRssiMin;
        g_cachedReading.probeRssiMax = probeRssiMax;
        g_cachedReading.cellRssi = g_cellRssi;

        // Try to re-initialize network for next time
        g_networkReady = false;
    }
}

// =============================================================================
// WiFi Geolocation Functions
// =============================================================================

// Perform WiFi scan to collect nearby access points for geolocation
static void performGeolocationScan() {
    Serial.println("[GEO] Scanning for WiFi networks...");
    g_wifiNetworkCount = 0;

    // Temporarily disable promiscuous mode for scanning
    esp_wifi_set_promiscuous(false);

    // Set WiFi to station mode for scanning
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    delay(100);

    // Perform scan (blocking)
    int numNetworks = WiFi.scanNetworks(false, false, false, 300);

    if (numNetworks < 0) {
        Serial.println("[GEO] WiFi scan failed");
        return;
    }

    Serial.printf("[GEO] Found %d networks\n", numNetworks);

    // Store top networks by signal strength (already sorted by RSSI)
    int count = min(numNetworks, MAX_WIFI_NETWORKS);
    for (int i = 0; i < count; i++) {
        // Get BSSID as string
        snprintf(g_wifiNetworks[i].bssid, sizeof(g_wifiNetworks[i].bssid),
                 "%02X:%02X:%02X:%02X:%02X:%02X",
                 WiFi.BSSID(i)[0], WiFi.BSSID(i)[1], WiFi.BSSID(i)[2],
                 WiFi.BSSID(i)[3], WiFi.BSSID(i)[4], WiFi.BSSID(i)[5]);
        g_wifiNetworks[i].rssi = WiFi.RSSI(i);
        g_wifiNetworks[i].channel = WiFi.channel(i);

        Serial.printf("[GEO]   %d: %s RSSI:%d CH:%d\n",
                      i + 1, g_wifiNetworks[i].bssid,
                      g_wifiNetworks[i].rssi, g_wifiNetworks[i].channel);
    }
    g_wifiNetworkCount = count;

    // Clear scan results to free memory
    WiFi.scanDelete();
}

// Send geolocation data to backend
static bool sendGeolocationData() {
    if (g_wifiNetworkCount == 0) {
        Serial.println("[GEO] No WiFi networks to send");
        return false;
    }

    Serial.printf("[GEO] Sending %d WiFi networks for geolocation...\n", g_wifiNetworkCount);

    // Build JSON payload
    // Format: {"d":"JBNB0001","wifi":[{"bssid":"AA:BB:CC:DD:EE:FF","rssi":-65,"ch":6},...]}
    char jsonPayload[512];
    int offset = snprintf(jsonPayload, sizeof(jsonPayload), "{\"d\":\"%s\",\"wifi\":[", DEVICE_ID);

    for (int i = 0; i < g_wifiNetworkCount && offset < (int)sizeof(jsonPayload) - 100; i++) {
        if (i > 0) {
            jsonPayload[offset++] = ',';
        }
        offset += snprintf(jsonPayload + offset, sizeof(jsonPayload) - offset,
                           "{\"bssid\":\"%s\",\"rssi\":%d,\"ch\":%d}",
                           g_wifiNetworks[i].bssid,
                           g_wifiNetworks[i].rssi,
                           g_wifiNetworks[i].channel);
    }
    offset += snprintf(jsonPayload + offset, sizeof(jsonPayload) - offset, "]}");

    size_t jsonLen = strlen(jsonPayload);

    // Build HTTP request
    char httpRequest[768];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        GEOLOCATION_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    Serial.printf("[GEO] Connecting to %s:%d\n", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[GEO] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    Serial.println("[GEO] Connected");
    delay(500);

    // Send data
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[GEO] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Send HTTP request data
    atSendRaw(httpRequest, httpLen);

    // Wait for send confirmation
    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[GEO] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Wait for HTTP response
    delay(2000);

    // Read response data
    atClearBuffer();
    uint32_t readStart = millis();
    while ((millis() - readStart) < 5000) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(100);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    if (g_atBufferLen > 0) {
        Serial.printf("[GEO] Response: %s\n", g_atBuffer);
    }

    // Check for HTTP success
    bool success = (strstr(g_atBuffer, "200") != NULL ||
                    strstr(g_atBuffer, "201") != NULL);

    // Close TCP connection
    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    if (success) {
        Serial.println("[GEO] Geolocation sent successfully");
    } else {
        Serial.println("[GEO] Geolocation send failed");
    }

    return success;
}

// =============================================================================
// Button Handling
// =============================================================================

static bool g_buttonPressed = false;
static uint32_t g_buttonPressTime = 0;

static void checkButton() {
    bool buttonState = (digitalRead(BUTTON_PIN) == LOW);

    if (buttonState && !g_buttonPressed) {
        // Button just pressed
        g_buttonPressed = true;
        g_buttonPressTime = millis();
        ledSetStatus(LED_STATUS_BUTTON_ACK);
    } else if (!buttonState && g_buttonPressed) {
        // Button released
        uint32_t pressDuration = millis() - g_buttonPressTime;
        g_buttonPressed = false;

        if (pressDuration > 3000) {
            // Long press (>3 seconds) - enter OTA mode
            Serial.println("[BTN] Long press - entering OTA mode");
            g_otaRequested = true;
        } else if (pressDuration > 100) {
            // Short press - send data packet immediately
            Serial.println("[BTN] Short press - sending data now");
            g_forceSendRequested = true;
        }
    }
}

static void checkResetButton() {
    static bool resetButtonPressed = false;
    static uint32_t resetButtonPressTime = 0;

    bool buttonState = (digitalRead(RESET_BUTTON_PIN) == LOW);

    if (buttonState && !resetButtonPressed) {
        resetButtonPressed = true;
        resetButtonPressTime = millis();
        ledSetStatus(LED_STATUS_BUTTON_ACK);
    } else if (!buttonState && resetButtonPressed) {
        uint32_t pressDuration = millis() - resetButtonPressTime;
        resetButtonPressed = false;

        if (pressDuration > 100) {
            Serial.println("[BTN] Reset button - rebooting...");
            delay(500);
            ESP.restart();
        }
    }
}

// =============================================================================
// Main Setup and Loop
// =============================================================================

void setup() {
    // Initialize USB Serial
    Serial.begin(115200);
    delay(2000);  // Wait for USB CDC

    Serial.println();
    Serial.println("========================================");
    Serial.printf("  NB-IoT JamBox Probe Counter v%s\n", FIRMWARE_VERSION);
    Serial.printf("  Device ID: %s\n", DEVICE_ID);
    Serial.printf("  Report interval: %lu minutes\n", REPORT_INTERVAL_MS / 60000);
    Serial.println("  Channel hopping: 1, 6, 11 (3s)");
    Serial.println("========================================");
    Serial.println();
    Serial.println("LED Status:");
    Serial.println("  PURPLE      = Booting");
    Serial.println("  RED (slow)  = Searching for network");
    Serial.println("  RED (fast)  = Error");
    Serial.println("  GREEN       = Connected, counting");
    Serial.println("  CYAN        = Transmitting");
    Serial.println("  GREEN       = Send successful");
    Serial.println("  BLUE        = Send failed");
    Serial.println("  YELLOW      = OTA mode");
    Serial.println();
    Serial.println("Buttons:");
    Serial.println("  Main short press  = Send data now");
    Serial.println("  Main long (3s)    = OTA mode");
    Serial.println("  Side button       = Reboot");
    Serial.println();

    // Initialize LED
    ledInit();
    ledSetStatus(LED_STATUS_BOOTING);

    // Initialize buttons
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);

    // Initialize modem serial
    ModemSerial.begin(MODEM_BAUD, SERIAL_8N1, MODEM_RX_PIN, MODEM_TX_PIN);
    delay(1000);

    // Set boot timestamp (would use NTP in production)
    g_bootTimestamp = 1737820800;  // 2025-01-25T12:00:00Z as placeholder

    // Perform WiFi geolocation scan FIRST (fast, before network init)
    Serial.println("[INIT] Performing geolocation scan...");
    performGeolocationScan();

    // Initialize network (can take 1-2 minutes for NB-IoT)
    Serial.println("[INIT] Initializing NB-IoT network...");
    if (!initializeNetwork()) {
        Serial.println("[INIT] Network init failed - will retry later");
        ledSetStatus(LED_STATUS_SEARCHING);
    }

    // Send geolocation data if we have network and found WiFi networks
    if (g_networkReady && g_wifiNetworkCount > 0) {
        Serial.println("[INIT] Sending geolocation data...");
        sendGeolocationData();
        g_geolocationPending = false;
    } else if (g_wifiNetworkCount == 0) {
        Serial.println("[INIT] No WiFi networks found for geolocation");
        g_geolocationPending = false;
    } else {
        Serial.println("[INIT] Network not ready, will send geolocation when connected");
        g_geolocationPending = true;
    }

    // Send initial heartbeat at boot
    if (g_networkReady) {
        Serial.println("[INIT] Sending initial heartbeat...");
        sendHeartbeat();
    }
    g_lastHeartbeatTime = millis();

    // Start probe capture
    Serial.println("[INIT] Starting probe capture...");
    startProbeCapture();

    // Initialize timing
    g_lastReportTime = millis();

    Serial.println("[INIT] Initialization complete");
    Serial.println("[INIT] Monitoring for probe requests...");
    Serial.println();
}

void loop() {
    uint32_t now = millis();

    // Update LED animation
    ledUpdate();

    // Update channel hopping (only when not in OTA mode)
    if (!g_otaInProgress) {
        updateChannelHop();
    }

    // Check buttons
    checkButton();
    checkResetButton();

    // Handle OTA mode
    if (g_otaRequested && !g_otaInProgress) {
        startOtaMode();
    }

    if (g_otaInProgress) {
        // In OTA mode - just handle web server
        if (g_otaServer) {
            g_otaServer->handleClient();
        }

        // Timeout check
        static uint32_t otaStartTime = 0;
        if (otaStartTime == 0) {
            otaStartTime = now;
        }
        if ((now - otaStartTime) > OTA_TIMEOUT_MS) {
            Serial.println("[OTA] Timeout - exiting OTA mode");
            otaStartTime = 0;
            stopOtaMode();
        }
        return;  // Skip normal loop processing during OTA
    }

    // Check if report interval has elapsed OR force send requested
    if ((now - g_lastReportTime) >= REPORT_INTERVAL_MS || g_forceSendRequested) {
        g_lastReportTime = now;
        g_forceSendRequested = false;

        Serial.println("\n[LOOP] Sending report...");

        // Temporarily stop probe capture during transmission
        stopProbeCapture();

        // Ensure network is ready
        if (!g_networkReady) {
            Serial.println("[LOOP] Re-initializing network...");
            initializeNetwork();
        }

        // Send pending geolocation if network just came up
        if (g_networkReady && g_geolocationPending && g_wifiNetworkCount > 0) {
            Serial.println("[LOOP] Sending pending geolocation data...");
            if (sendGeolocationData()) {
                g_geolocationPending = false;
            }
        }

        // Send report
        reportCounts();

        // Resume probe capture
        startProbeCapture();

        Serial.println("[LOOP] Resuming probe capture\n");
    }

    // Daily heartbeat (every 24 hours)
    if ((now - g_lastHeartbeatTime) >= HEARTBEAT_INTERVAL_MS) {
        g_lastHeartbeatTime = now;
        if (g_networkReady) {
            Serial.println("[LOOP] Sending daily heartbeat...");
            sendHeartbeat();
        }
    }

    // Periodic status (every 60 seconds)
    static uint32_t lastStatus = 0;
    if ((now - lastStatus) >= 60000) {
        lastStatus = now;

        uint32_t probes, unique, apple, android, other, filtered;
        int probeRssiAvg = 0;
        portENTER_CRITICAL(&g_probeMux);
        probes = g_totalProbes;
        unique = g_uniqueMacs.size();
        apple = g_appleCount;
        android = g_androidCount;
        other = g_otherCount;
        filtered = g_filteredStatic;
        if (g_probeRssiCount > 0) {
            probeRssiAvg = g_probeRssiSum / (int32_t)g_probeRssiCount;
        }
        portEXIT_CRITICAL(&g_probeMux);

        uint32_t nextReport = (REPORT_INTERVAL_MS - (now - g_lastReportTime)) / 1000;
        Serial.printf("[STATUS] CH:%d Probes:%lu Unique:%lu Apple:%lu Android:%lu Other:%lu Filtered:%lu ProbeRSSI:%d Next:%lu sec\n",
                      WIFI_CHANNELS[g_currentChannelIndex], probes, unique, apple, android, other, filtered, probeRssiAvg, nextReport);
    }

    // Small delay to yield to other tasks
    delay(10);
}
