/**
 * NB-IoT JamBox Probe Counter Firmware
 *
 * M5Stack AtomS3 DTU-NB-IoT (ESP32-S3 + SIM7028)
 *
 * Captures 802.11 probe requests using WiFi promiscuous mode,
 * counts unique MAC addresses, and reports to backend via NB-IoT.
 *
 * Hardware Configuration:
 *   - GPIO5 = ESP32 TX -> Modem RX
 *   - GPIO6 = ESP32 RX <- Modem TX
 *   - GPIO35 = Built-in RGB LED (WS2812, directly driven)
 *   - GPIO41 = Button
 *
 * LED Status Colors:
 *   - PURPLE: Booting / initializing
 *   - RED (slow blink): Searching for network
 *   - RED (fast blink): Critical error
 *   - GREEN: Connected, counting probes
 *   - CYAN (pulse): Transmitting data
 *   - GREEN (3 sec): Send successful
 *   - BLUE (slow blink): Send failed
 *   - YELLOW (pulse): OTA update mode
 *   - WHITE (flash): Button press acknowledged
 *
 * Backend: http://172.233.144.32:5000/api/reading
 * Auth: Bearer token
 * Payload: {"d":"NB000001","t":TIMESTAMP,"i":IMPRESSIONS,"u":UNIQUE,"sig":SIGNAL}
 *
 * OTA Update:
 *   Backend can trigger OTA mode by including "ota":true in response.
 *   Device will then enter WiFi AP mode for local firmware update.
 */

#include <Arduino.h>
#include <WiFi.h>
#include <esp_wifi.h>
#include <WebServer.h>
#include <Update.h>
#include <FastLED.h>
#include <NimBLEDevice.h>
// Removed std::set and std::map - using fixed arrays to prevent heap fragmentation
#include <time.h>
#include <esp_task_wdt.h>
#include <Preferences.h>   // NVS for OTA state persistence
#include <SPIFFS.h>        // File system for patch storage
#include <mbedtls/sha256.h> // SHA-256 for patch verification

// ESP-IDF OTA rollback protection
extern "C" {
    #include "esp_ota_ops.h"
}

// =============================================================================
// Device Type Classification (BLE Manufacturer ID based)
// =============================================================================

enum DeviceType { DEVICE_APPLE, DEVICE_OTHER };

// BLE Manufacturer ID for Apple - the only one we can reliably detect
// Android detection via manufacturer IDs is unreliable (fragmented ecosystem)
#define BLE_MANUFACTURER_APPLE 0x004C  // Apple Inc.

// Classify device based on BLE manufacturer ID
// Returns DEVICE_APPLE for Apple devices, DEVICE_OTHER for everything else
static DeviceType classifyBleDevice(uint16_t manufacturerId) {
    if (manufacturerId == BLE_MANUFACTURER_APPLE) {
        return DEVICE_APPLE;
    }
    return DEVICE_OTHER;
}

// =============================================================================
// Configuration
// =============================================================================

// Include device-specific configuration (generated by NBJBTOOL.sh)
#include "device_config.h"

// Firmware version - v5.5: Consolidated release (v5.4 features + verified time sync fix)
static const char* FIRMWARE_VERSION = "5.5";

// SSL Configuration (disabled for now - AT+CCHOPEN failing)
#define USE_SSL false
#define SSL_CTX_INDEX 0  // SSL context index (0-5)

// Timing configuration (milliseconds)
static const uint32_t AT_COMMAND_TIMEOUT_MS = 10000;
static const uint32_t TCP_CONNECT_TIMEOUT_MS = 30000;
static const uint32_t NETWORK_INIT_TIMEOUT_MS = 120000;

// Pin definitions for AtomS3 DTU-NB-IoT
#define MODEM_TX_PIN    5       // ESP32 TX -> Modem RX
#define MODEM_RX_PIN    6       // ESP32 RX <- Modem TX
#define MODEM_BAUD      115200
#define LED_PIN         35      // AtomS3 RGB LED (WS2812)
#define BUTTON_PIN      41      // AtomS3 Main Button (front)
#define RESET_BUTTON_PIN 39     // AtomS3 Side Button (reset/reboot)
#define NUM_LEDS        1       // Single RGB LED

// WiFi channel hopping configuration
// Channels 1, 6, 11 are non-overlapping 2.4GHz channels
static const uint8_t WIFI_CHANNELS[] = {1, 6, 11};
static const uint8_t WIFI_CHANNEL_COUNT = 3;
static const uint32_t CHANNEL_HOP_INTERVAL_MS = 3000;  // 3 seconds per channel

// BLE/WiFi time-slicing configuration
// ESP32 shares radio between WiFi and BLE, so we alternate
static const uint32_t WIFI_SCAN_DURATION_MS = 29000;   // 29 seconds WiFi promiscuous mode
static const uint32_t BLE_SCAN_DURATION_MS = 1000;     // 1 second BLE scanning (minimum for NimBLE)
// 97/3 split: BLE sampled briefly for device composition (Apple vs Other)
// WiFi gets nearly all time for accurate probe counting

// Maximum unique MACs to track per period (raised from 500 to prevent silent data loss)
#define MAX_UNIQUE_MACS 2000

// Privacy: Only count randomized MACs (filters out static/PII MACs)
// Randomized MACs have bit 1 of first byte set (locally administered)
// Static MACs are globally unique and considered PII under GDPR/CCPA
#define PRIVACY_FILTER_ENABLED true

// Access point counting (beacons) - disabled by default
static bool g_countAccessPoints = false;

// =============================================================================
// Remote Configuration (v5.4)
// These defaults can be overridden via backend /api/config endpoint
// Device fetches config when config_version changes (detected in heartbeat/reading response)
// =============================================================================

// RSSI thresholds for distance zone classification (dBm)
static int g_rssiImmediateThreshold = -50;  // At Counter (very close, 0-2m)
static int g_rssiNearThreshold = -65;       // In Store (near, 2-5m)
static int g_rssiFarThreshold = -80;        // Window Shopping (far, 5-15m)
// Anything below g_rssiFarThreshold is "Walking Past" (remote, >15m)

// Dwell time bucket thresholds (minutes)
static uint8_t g_dwellShortThreshold = 1;   // Quick Glance boundary (0 to X min)
static uint8_t g_dwellMediumThreshold = 5;  // Browsing boundary (X to Y min)
static uint8_t g_dwellLongThreshold = 10;   // Shopping boundary (Y to Z min)
// Anything above g_dwellLongThreshold is "Loyal Customer"

// Config version tracking - device fetches new config when server version is higher
static uint32_t g_configVersion = 0;

// Maximum unique APs to track
#define MAX_UNIQUE_APS 100

// =============================================================================
// Delta OTA Configuration
// =============================================================================

// OTA chunk size (must match backend)
#define OTA_CHUNK_SIZE 512

// Maximum retries per chunk before aborting
#define OTA_MAX_CHUNK_RETRIES 3

// OTA state machine states
enum OtaDeltaState {
    OTA_DELTA_IDLE = 0,       // No OTA in progress
    OTA_DELTA_CHECKING,       // Checking for updates
    OTA_DELTA_DOWNLOADING,    // Downloading patch chunks
    OTA_DELTA_VERIFYING,      // Verifying complete patch
    OTA_DELTA_APPLYING,       // Applying delta patch to OTA partition
    OTA_DELTA_REBOOTING       // About to reboot to new firmware
};

// OTA endpoint paths
#define OTA_CHECK_PATH "/api/ota/check"
#define OTA_CHUNK_PATH "/api/ota/chunk"
#define OTA_COMPLETE_PATH "/api/ota/complete"

// Patch file path in SPIFFS
#define OTA_PATCH_FILE "/patch.bin"

// NVS namespace for OTA state persistence
#define OTA_NVS_NAMESPACE "ota_delta"

// =============================================================================
// WiFi Geolocation Scan Configuration
// =============================================================================

// Maximum WiFi networks to scan for geolocation
#define MAX_WIFI_NETWORKS 10

// Note: GEOLOCATION_PATH is defined in device_config.h

// WiFi network info for geolocation
struct WifiNetwork {
    char bssid[18];  // "AA:BB:CC:DD:EE:FF" format
    int rssi;
    int channel;
};

static WifiNetwork g_wifiNetworks[MAX_WIFI_NETWORKS];
static int g_wifiNetworkCount = 0;

// =============================================================================
// LED Status Definitions
// =============================================================================

// LED Status states
enum LedStatus {
    LED_STATUS_BOOTING,        // PURPLE - Initializing modem/boot sequence
    LED_STATUS_SEARCHING,      // RED slow blink - Looking for network
    LED_STATUS_ERROR,          // RED fast blink - Critical error (SIM/modem fail)
    LED_STATUS_CONNECTED,      // CYAN solid - Connected, counting, waiting
    LED_STATUS_TRANSMITTING,   // ORANGE flash - Sending data
    LED_STATUS_SEND_SUCCESS,   // GREEN solid (3 sec) - Send successful
    LED_STATUS_SEND_FAILED,    // BLUE slow blink - Connected but send failed
    LED_STATUS_OTA_MODE,       // YELLOW pulsing - WiFi AP for update
    LED_STATUS_BUTTON_ACK      // WHITE flash - Button press acknowledged
};

// LED Colors (GRB order for WS2812)
#define COLOR_OFF       CRGB::Black
#define COLOR_GREEN     CRGB::Green
#define COLOR_RED       CRGB::Red
#define COLOR_BLUE      CRGB::Blue
#define COLOR_YELLOW    CRGB::Yellow
#define COLOR_ORANGE    CRGB::Orange
#define COLOR_PURPLE    CRGB::Purple
#define COLOR_CYAN      CRGB::Cyan
#define COLOR_WHITE     CRGB::White

// =============================================================================
// Global State
// =============================================================================

// FastLED array
CRGB g_leds[NUM_LEDS];

// Current LED status
static LedStatus g_ledStatus = LED_STATUS_SEARCHING;
static uint32_t g_lastLedUpdate = 0;
static bool g_ledBlinkState = false;

// UART for modem
HardwareSerial ModemSerial(1);

// WiFi probe counting state
static volatile uint32_t g_totalProbes = 0;
static volatile uint32_t g_filteredStatic = 0;  // Count of rejected static MACs
// Fixed arrays for MAC deduplication - prevents heap fragmentation in 24/7 operation
static uint64_t g_uniqueMacs[MAX_UNIQUE_MACS];
static uint16_t g_uniqueMacCount = 0;
// Overflow counters - track when caps are hit (data quality indicator)
static volatile uint16_t g_uniqueOverflow = 0;  // WiFi uniques dropped due to cap
static volatile uint16_t g_bleOverflow = 0;     // BLE uniques dropped due to cap
// Fixed array for access point BSSIDs
static uint64_t g_uniqueAPs[MAX_UNIQUE_APS];
static uint16_t g_uniqueAPCount = 0;
static portMUX_TYPE g_probeMux = portMUX_INITIALIZER_UNLOCKED;

// Helper: Check if MAC exists in array, add if not. Returns true if newly added.
static bool addUniqueMac(uint64_t* array, uint16_t* count, uint16_t maxSize, uint64_t mac) {
    // Linear search is O(n) but fast for 500 entries (~microseconds)
    for (uint16_t i = 0; i < *count; i++) {
        if (array[i] == mac) {
            return false;  // Already exists
        }
    }
    if (*count < maxSize) {
        array[*count] = mac;
        (*count)++;
        return true;  // Newly added
    }
    return false;  // Array full, not added
}

// BLE counting state - Apple detection via manufacturer ID 0x004C
static volatile uint32_t g_bleImpressions = 0;  // Total BLE advertisements
static volatile uint32_t g_bleAppleCount = 0;   // Apple devices (0x004C) - reliable
static volatile uint32_t g_bleOtherCount = 0;   // Everything else (Android, wearables, IoT)
static volatile int32_t g_bleRssiSum = 0;       // Sum for average calculation
static volatile uint32_t g_bleRssiCount = 0;    // Count for average
// Fixed array for BLE MAC deduplication - prevents heap fragmentation
static uint64_t g_bleUniqueMacs[MAX_UNIQUE_MACS];
static uint16_t g_bleUniqueMacCount = 0;
static portMUX_TYPE g_bleMux = portMUX_INITIALIZER_UNLOCKED;

// Radio time-slicing state
enum RadioMode { RADIO_WIFI, RADIO_BLE };
static RadioMode g_radioMode = RADIO_WIFI;
static uint32_t g_lastRadioSwitch = 0;
static bool g_bleInitialized = false;

// Probe RSSI tracking (WiFi signal strength from phones)
static volatile int32_t g_probeRssiSum = 0;
static volatile int32_t g_probeRssiMin = 0;      // Min RSSI (closest device)
static volatile int32_t g_probeRssiMax = -999;   // Max RSSI (farthest device)
static volatile uint32_t g_probeRssiCount = 0;

// Dwell time tracking - tracks how long each device stays in range
// Using parallel arrays instead of std::map to prevent heap fragmentation
#define MAX_DWELL_ENTRIES 1000
static uint64_t g_dwellMacs[MAX_DWELL_ENTRIES];
static uint16_t g_dwellFirstSeen[MAX_DWELL_ENTRIES];
static uint16_t g_dwellLastSeen[MAX_DWELL_ENTRIES];
static uint16_t g_dwellCount = 0;

// Helper: Find existing dwell entry or add new one. Returns index, or -1 if full.
static int findOrAddDwellEntry(uint64_t mac) {
    // Search for existing entry
    for (uint16_t i = 0; i < g_dwellCount; i++) {
        if (g_dwellMacs[i] == mac) {
            return (int)i;  // Found existing
        }
    }
    // Add new entry if space available
    if (g_dwellCount < MAX_DWELL_ENTRIES) {
        int idx = g_dwellCount;
        g_dwellMacs[idx] = mac;
        g_dwellCount++;
        return idx;
    }
    return -1;  // Array full
}

// Dwell time bucket counters (calculated at report time)
// These track engagement levels:
// - 0-1 min: Drive-by traffic (saw device in only 1 minute)
// - 1-5 min: Brief stop (2-5 distinct minutes)
// - 5-10 min: Engaged visitor
// - 10+ min: Highly engaged (lingered 10+ minutes)
static volatile uint32_t g_dwell_0_1 = 0;
static volatile uint32_t g_dwell_1_5 = 0;
static volatile uint32_t g_dwell_5_10 = 0;
static volatile uint32_t g_dwell_10plus = 0;

// RSSI distance zone counters (proves viewability)
// - Immediate: > -50 dBm (within ~2m, very close)
// - Near: -50 to -65 dBm (~2-5m, clearly visible)
// - Far: -65 to -80 dBm (~5-15m, in vicinity)
// - Remote: < -80 dBm (>15m, passing by)
static volatile uint32_t g_rssi_immediate = 0;
static volatile uint32_t g_rssi_near = 0;
static volatile uint32_t g_rssi_far = 0;
static volatile uint32_t g_rssi_remote = 0;

// Timing
static uint32_t g_lastReportTime = 0;
static uint32_t g_lastHeartbeatTime = 0;
static uint32_t g_bootTimestamp = 0;  // Pseudo-timestamp from boot

// Channel hopping state
static uint8_t g_currentChannelIndex = 0;
static uint32_t g_lastChannelHop = 0;

// OTA rollback protection - confirms new firmware works after first successful send
static bool g_otaConfirmed = false;

// Cached reading structure for offline resilience
struct CachedReading {
    bool valid;
    char timestamp[25];
    uint32_t cachedAtMillis;   // millis() when this was cached (for age calculation)
    uint16_t overflowCount;    // Overflow count when this reading was captured
    uint32_t impressions;
    uint32_t unique;
    int probeRssiAvg;
    int probeRssiMin;
    int probeRssiMax;
    int cellRssi;
    uint32_t dwell_0_1;
    uint32_t dwell_1_5;
    uint32_t dwell_5_10;
    uint32_t dwell_10plus;
    uint32_t rssi_immediate;
    uint32_t rssi_near;
    uint32_t rssi_far;
    uint32_t rssi_remote;
    // BLE counting fields (v4.0) - Apple vs Other
    uint32_t bleImpressions;
    uint32_t bleUnique;
    uint32_t bleApple;
    uint32_t bleOther;
    int bleRssiAvg;
};

// Circular buffer for cached readings (48hr at 30-min intervals, or 8hr at 5-min)
#define MAX_CACHED_READINGS 96
static CachedReading g_cacheBuffer[MAX_CACHED_READINGS];
static uint8_t g_cacheHead = 0;   // Next write position
static uint8_t g_cacheTail = 0;   // Next read position
static uint8_t g_cacheCount = 0;  // Number of valid entries

// Cache a reading for later retry (returns true if cached, false if full)
static bool cacheReading(const CachedReading& reading) {
    if (g_cacheCount >= MAX_CACHED_READINGS) {
        Serial.println("[CACHE] Buffer full, dropping oldest reading");
        // Drop oldest by advancing tail
        g_cacheTail = (g_cacheTail + 1) % MAX_CACHED_READINGS;
        g_cacheCount--;
    }
    g_cacheBuffer[g_cacheHead] = reading;
    g_cacheBuffer[g_cacheHead].valid = true;
    g_cacheHead = (g_cacheHead + 1) % MAX_CACHED_READINGS;
    g_cacheCount++;
    Serial.printf("[CACHE] Cached reading (%d/%d slots used)\n", g_cacheCount, MAX_CACHED_READINGS);
    return true;
}

// Pop oldest cached reading (returns true if found, false if empty)
static bool popCachedReading(CachedReading* reading) {
    if (g_cacheCount == 0) {
        return false;
    }
    *reading = g_cacheBuffer[g_cacheTail];
    g_cacheBuffer[g_cacheTail].valid = false;
    g_cacheTail = (g_cacheTail + 1) % MAX_CACHED_READINGS;
    g_cacheCount--;
    return true;
}

// Network state
static bool g_networkReady = false;
static int g_cellRssi = 0;          // Cellular signal strength (dBm)
static bool g_lastSendSuccess = false;

// Quality tracking for auditability
static uint8_t g_sendFailures = 0;         // Consecutive send failures (reset on success)

// Geolocation state - flag to send once network connects
static bool g_geolocationPending = false;

// Time sync state - set true once time is synced from backend
static bool g_timeSynced = false;

// WiFi AP OTA state (existing local update mode)
static bool g_otaRequested = false;
static bool g_otaInProgress = false;
static WebServer* g_otaServer = nullptr;

// =============================================================================
// Delta OTA State (NB-IoT remote update)
// =============================================================================

// Delta OTA state structure - persisted to NVS for crash recovery
struct OtaDeltaInfo {
    OtaDeltaState state;           // Current OTA state machine state
    char targetVersion[16];        // Version we're updating to (e.g., "4.7")
    char currentVersion[16];       // Version we're updating from
    uint32_t patchSize;            // Total patch size in bytes
    uint16_t totalChunks;          // Total number of chunks
    uint16_t chunksReceived;       // Chunks successfully downloaded
    char patchSha256[65];          // Expected SHA-256 of complete patch (hex string)
    uint32_t lastChunkTime;        // millis() of last successful chunk (for timeout)
    uint8_t chunkRetries;          // Retries for current chunk
    bool checkPending;             // Flag to trigger OTA check (from command)
};

static OtaDeltaInfo g_otaDelta = {};
static Preferences g_otaNvs;       // NVS handle for persistence
static bool g_spiffsReady = false; // SPIFFS initialization status

// Forward declarations for OTA functions (defined later, used in command handlers)
static void triggerOtaCheck();

// Button state
static bool g_forceSendRequested = false;

// Remote configuration fetch flag (v5.4)
static bool g_configFetchPending = false;

// AT response buffer
static char g_atBuffer[512];
static size_t g_atBufferLen = 0;

// =============================================================================
// LED Control Functions
// =============================================================================

static void ledInit() {
    FastLED.addLeds<WS2812, LED_PIN, GRB>(g_leds, NUM_LEDS);
    FastLED.setBrightness(50);  // Moderate brightness to save power
    g_leds[0] = COLOR_OFF;
    FastLED.show();
}

static void ledSetColor(CRGB color) {
    g_leds[0] = color;
    FastLED.show();
}

static void ledSetStatus(LedStatus status) {
    g_ledStatus = status;
    g_lastLedUpdate = millis();
    g_ledBlinkState = true;

    // Set initial color based on status
    switch (status) {
        case LED_STATUS_BOOTING:
            ledSetColor(COLOR_PURPLE);
            break;
        case LED_STATUS_SEARCHING:
            ledSetColor(COLOR_RED);
            break;
        case LED_STATUS_ERROR:
            ledSetColor(COLOR_RED);
            break;
        case LED_STATUS_CONNECTED:
            ledSetColor(COLOR_GREEN);
            break;
        case LED_STATUS_TRANSMITTING:
            ledSetColor(COLOR_CYAN);
            break;
        case LED_STATUS_SEND_SUCCESS:
            ledSetColor(COLOR_GREEN);
            break;
        case LED_STATUS_SEND_FAILED:
            ledSetColor(COLOR_BLUE);
            break;
        case LED_STATUS_OTA_MODE:
            ledSetColor(COLOR_YELLOW);
            break;
        case LED_STATUS_BUTTON_ACK:
            ledSetColor(COLOR_WHITE);
            break;
    }
}

// Update LED animation (call from loop)
static void ledUpdate() {
    uint32_t now = millis();
    uint32_t elapsed = now - g_lastLedUpdate;

    switch (g_ledStatus) {
        case LED_STATUS_BOOTING:
            // Solid purple - no animation
            break;

        case LED_STATUS_SEARCHING:
            // Slow blink red (500ms on, 500ms off)
            if (elapsed >= 500) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_RED : COLOR_OFF);
            }
            break;

        case LED_STATUS_ERROR:
            // Fast blink red (100ms on, 100ms off)
            if (elapsed >= 100) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_RED : COLOR_OFF);
            }
            break;

        case LED_STATUS_CONNECTED:
            // Solid cyan with brief dim every 2s to show alive
            if (elapsed >= 2000) {
                g_lastLedUpdate = now;
                FastLED.setBrightness(20);
                FastLED.show();
                delay(50);
                FastLED.setBrightness(50);
                FastLED.show();
            }
            break;

        case LED_STATUS_TRANSMITTING:
            // Fast pulse cyan
            if (elapsed >= 150) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_CYAN : COLOR_OFF);
            }
            break;

        case LED_STATUS_SEND_SUCCESS:
            // Solid green for 3 seconds, then return to connected
            if (elapsed >= 3000) {
                ledSetStatus(LED_STATUS_CONNECTED);
            }
            break;

        case LED_STATUS_SEND_FAILED:
            // Slow blink blue (1s on, 1s off)
            if (elapsed >= 1000) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_BLUE : COLOR_OFF);
            }
            break;

        case LED_STATUS_OTA_MODE:
            // Fast pulse yellow
            if (elapsed >= 200) {
                g_lastLedUpdate = now;
                g_ledBlinkState = !g_ledBlinkState;
                ledSetColor(g_ledBlinkState ? COLOR_YELLOW : COLOR_ORANGE);
            }
            break;

        case LED_STATUS_BUTTON_ACK:
            // White flash, then return to previous state
            if (elapsed >= 200) {
                ledSetStatus(g_networkReady ? LED_STATUS_CONNECTED : LED_STATUS_SEARCHING);
            }
            break;
    }
}

// Brief flash for activity indication (non-blocking setup)
static void ledFlash(CRGB color, int count, int onMs) {
    for (int i = 0; i < count; i++) {
        ledSetColor(color);
        delay(onMs);
        ledSetColor(COLOR_OFF);
        if (i < count - 1) delay(onMs);
    }
    // Restore status color
    ledSetStatus(g_ledStatus);
}

// =============================================================================
// WiFi Promiscuous Mode - Probe Request Capture
// =============================================================================

// 802.11 frame type definitions
#define WIFI_MGMT_FRAME     0
#define WIFI_PROBE_REQUEST  4
#define WIFI_BEACON         8

// Check if MAC address is randomized (locally administered)
// Bit 1 of first byte: 0 = globally unique (static), 1 = locally administered (randomized)
static inline bool isRandomizedMac(const uint8_t* mac) {
    return (mac[0] & 0x02) != 0;
}

// WiFi promiscuous callback - called from WiFi task context
static void IRAM_ATTR wifiProbeCounterCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
    if (type != WIFI_PKT_MGMT) return;

    const wifi_promiscuous_pkt_t* pkt = (wifi_promiscuous_pkt_t*)buf;
    const uint8_t* frame = pkt->payload;
    const int len = pkt->rx_ctrl.sig_len;

    // Need at least frame control + duration + 3 addresses (24 bytes)
    if (len < 24) return;

    // Frame control field (first 2 bytes)
    uint8_t frameType = (frame[0] >> 2) & 0x03;     // bits 2-3
    uint8_t frameSubtype = (frame[0] >> 4) & 0x0F;  // bits 4-7

    // Only process management frames
    if (frameType != WIFI_MGMT_FRAME) return;

    // Handle beacon frames (access point counting)
    if (frameSubtype == WIFI_BEACON && g_countAccessPoints) {
        // BSSID is at bytes 16-21 in beacon frame
        const uint8_t* bssid = &frame[16];
        uint64_t bssidVal = 0;
        for (int i = 0; i < 6; i++) {
            bssidVal = (bssidVal << 8) | bssid[i];
        }

        portENTER_CRITICAL(&g_probeMux);
        addUniqueMac(g_uniqueAPs, &g_uniqueAPCount, MAX_UNIQUE_APS, bssidVal);
        portEXIT_CRITICAL(&g_probeMux);
        return;
    }

    // Filter for probe requests only (subtype=4)
    if (frameSubtype != WIFI_PROBE_REQUEST) return;

    // Extract source MAC address (bytes 10-15 in 802.11 header)
    // Header: FC(2) + Duration(2) + DA(6) + SA(6) + BSSID(6) + SeqCtrl(2)
    const uint8_t* srcMac = &frame[10];

    // Privacy filter: Only count randomized MACs
    // Static MACs are globally unique (PII) - we reject them
#if PRIVACY_FILTER_ENABLED
    if (!isRandomizedMac(srcMac)) {
        portENTER_CRITICAL(&g_probeMux);
        g_filteredStatic++;
        portEXIT_CRITICAL(&g_probeMux);
        return;
    }
#endif

    // Note: WiFi probe requests don't reliably indicate device type
    // OS classification now done via BLE manufacturer IDs

    // Convert MAC to uint64_t for set storage
    uint64_t macVal = 0;
    for (int i = 0; i < 6; i++) {
        macVal = (macVal << 8) | srcMac[i];
    }

    // Create dedup key: MAC (48 bits) + current minute (16 bits)
    // This counts each device once per minute (MRC "opportunity to see" standard)
    uint32_t currentMinute = millis() / 60000;
    uint64_t dedupKey = macVal | ((uint64_t)(currentMinute & 0xFFFF) << 48);

    // Capture probe RSSI (WiFi signal strength from the phone)
    int probeRssi = pkt->rx_ctrl.rssi;

    // Update counters with mutex protection
    portENTER_CRITICAL(&g_probeMux);
    g_totalProbes++;
    // Track overflow when cap is hit (data quality indicator)
    if (!addUniqueMac(g_uniqueMacs, &g_uniqueMacCount, MAX_UNIQUE_MACS, dedupKey)) {
        g_uniqueOverflow++;
    }
    // Track probe RSSI stats
    g_probeRssiSum += probeRssi;
    g_probeRssiCount++;
    if (probeRssi < g_probeRssiMin || g_probeRssiMin == 0) {
        g_probeRssiMin = probeRssi;
    }
    if (probeRssi > g_probeRssiMax) {
        g_probeRssiMax = probeRssi;
    }
    // Categorize by RSSI distance zone (thresholds configurable via remote config)
    if (probeRssi > g_rssiImmediateThreshold) {
        g_rssi_immediate++;  // At Counter (very close, ~0-2m)
    } else if (probeRssi > g_rssiNearThreshold) {
        g_rssi_near++;       // In Store (near, ~2-5m)
    } else if (probeRssi > g_rssiFarThreshold) {
        g_rssi_far++;        // Window Shopping (far, ~5-15m)
    } else {
        g_rssi_remote++;     // Walking Past (remote, >15m)
    }
    // Track dwell time - record first and last minute each MAC was seen
    uint16_t minuteVal = (uint16_t)(currentMinute & 0xFFFF);
    int dwellIdx = findOrAddDwellEntry(macVal);
    if (dwellIdx >= 0) {
        if (g_dwellFirstSeen[dwellIdx] == 0 || g_dwellMacs[dwellIdx] != macVal) {
            // New entry - first time seeing this MAC
            g_dwellFirstSeen[dwellIdx] = minuteVal;
        }
        g_dwellLastSeen[dwellIdx] = minuteVal;
    }
    portEXIT_CRITICAL(&g_probeMux);
}

static void startProbeCapture() {
    Serial.println("[PROBE] Starting WiFi promiscuous mode...");

    // Initialize WiFi in station mode first
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    delay(100);

    // Initialize channel hopping state
    g_currentChannelIndex = 0;
    g_lastChannelHop = millis();
    esp_wifi_set_channel(WIFI_CHANNELS[g_currentChannelIndex], WIFI_SECOND_CHAN_NONE);

    // Configure promiscuous filter for management frames only
    wifi_promiscuous_filter_t filter = {
        .filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT
    };
    esp_wifi_set_promiscuous_filter(&filter);

    // Register callback and enable promiscuous mode
    esp_wifi_set_promiscuous_rx_cb(&wifiProbeCounterCallback);
    esp_wifi_set_promiscuous(true);

    Serial.printf("[PROBE] Channel hopping enabled: 1, 6, 11 (3s interval)\n");
    Serial.printf("[PROBE] Starting on channel %d\n", WIFI_CHANNELS[g_currentChannelIndex]);
}

static void stopProbeCapture() {
    esp_wifi_set_promiscuous(false);
    Serial.println("[PROBE] Promiscuous mode stopped");
}

// Channel hopping - call from main loop
static void updateChannelHop() {
    uint32_t now = millis();
    if ((now - g_lastChannelHop) >= CHANNEL_HOP_INTERVAL_MS) {
        g_lastChannelHop = now;
        g_currentChannelIndex = (g_currentChannelIndex + 1) % WIFI_CHANNEL_COUNT;
        esp_wifi_set_channel(WIFI_CHANNELS[g_currentChannelIndex], WIFI_SECOND_CHAN_NONE);
    }
}

// =============================================================================
// BLE Passive Scanning - Accurate OS Detection via Manufacturer IDs
// =============================================================================

// NimBLE advertised device callback
class BleAdvertisedDeviceCallbacks : public NimBLEAdvertisedDeviceCallbacks {
    void onResult(NimBLEAdvertisedDevice* advertisedDevice) override {
        // Get address (check for randomized MAC)
        NimBLEAddress addr = advertisedDevice->getAddress();
        uint8_t addrType = addr.getType();

        // Only count randomized addresses (privacy filter)
        // Type 1 = Random Address, Type 0 = Public Address
        if (addrType == 0) {
            // Public (static) address - skip for privacy
            return;
        }

        // Get MAC as bytes
        const uint8_t* macBytes = addr.getNative();
        uint64_t macVal = 0;
        for (int i = 0; i < 6; i++) {
            macVal = (macVal << 8) | macBytes[i];
        }

        // Per-minute deduplication (same as WiFi probes)
        uint32_t currentMinute = millis() / 60000;
        uint64_t dedupKey = macVal | ((uint64_t)(currentMinute & 0xFFFF) << 48);

        // Get signal strength
        int rssi = advertisedDevice->getRSSI();

        // Classify by manufacturer ID
        DeviceType deviceType = DEVICE_OTHER;
        if (advertisedDevice->haveManufacturerData()) {
            std::string mfgData = advertisedDevice->getManufacturerData();
            if (mfgData.length() >= 2) {
                // Manufacturer ID is little-endian first 2 bytes
                uint16_t mfgId = ((uint8_t)mfgData[1] << 8) | (uint8_t)mfgData[0];
                deviceType = classifyBleDevice(mfgId);
            }
        }

        // Update counters with mutex protection
        portENTER_CRITICAL(&g_bleMux);
        g_bleImpressions++;  // Raw count: every advertisement

        // Track unique per minute - only count OS type for NEW devices
        // addUniqueMac returns true if this is a new device (not seen before)
        bool isNewDevice = addUniqueMac(g_bleUniqueMacs, &g_bleUniqueMacCount, MAX_UNIQUE_MACS, dedupKey);
        if (isNewDevice) {
            if (deviceType == DEVICE_APPLE) {
                g_bleAppleCount++;
            } else {
                g_bleOtherCount++;
            }
        } else if (g_bleUniqueMacCount >= MAX_UNIQUE_MACS) {
            // Track BLE overflow separately (cap was hit)
            g_bleOverflow++;
        }

        // Track RSSI (still count every advertisement for signal averaging)
        g_bleRssiSum += rssi;
        g_bleRssiCount++;
        portEXIT_CRITICAL(&g_bleMux);
    }
};

static NimBLEScan* g_pBleScan = nullptr;
static BleAdvertisedDeviceCallbacks g_bleCallbacks;

static void initBle() {
    if (g_bleInitialized) return;

    Serial.println("[BLE] Initializing NimBLE...");

    // Initialize NimBLE in passive mode (no transmit)
    NimBLEDevice::init("");

    // Get scan object
    g_pBleScan = NimBLEDevice::getScan();
    g_pBleScan->setAdvertisedDeviceCallbacks(&g_bleCallbacks, false);
    g_pBleScan->setActiveScan(false);  // Passive scan - no scan requests
    g_pBleScan->setInterval(100);      // 100ms scan interval
    g_pBleScan->setWindow(99);         // 99ms scan window (nearly continuous)
    g_pBleScan->setMaxResults(0);      // Don't store results, use callback

    g_bleInitialized = true;
    Serial.println("[BLE] NimBLE initialized (passive scan mode)");
}

static void startBleScan() {
    if (!g_bleInitialized) {
        initBle();
    }

    if (g_pBleScan && !g_pBleScan->isScanning()) {
        // Start scanning for BLE_SCAN_DURATION_MS (non-blocking)
        g_pBleScan->start(BLE_SCAN_DURATION_MS / 1000, false);
        Serial.println("[BLE] Scanning started");
    }
}

static void stopBleScan() {
    if (g_pBleScan && g_pBleScan->isScanning()) {
        g_pBleScan->stop();
        Serial.println("[BLE] Scanning stopped");
    }
}

// Radio time-slicing: switches between WiFi and BLE modes
static void updateRadioMode() {
    uint32_t now = millis();
    uint32_t elapsed = now - g_lastRadioSwitch;

    if (g_radioMode == RADIO_WIFI) {
        // Currently in WiFi mode - check if time to switch to BLE
        if (elapsed >= WIFI_SCAN_DURATION_MS) {
            g_lastRadioSwitch = now;
            g_radioMode = RADIO_BLE;

            // Stop WiFi promiscuous mode
            stopProbeCapture();

            // Start BLE scanning
            startBleScan();
        } else {
            // Still in WiFi mode - do channel hopping
            updateChannelHop();
        }
    } else {
        // Currently in BLE mode - check if time to switch back to WiFi
        if (elapsed >= BLE_SCAN_DURATION_MS) {
            g_lastRadioSwitch = now;
            g_radioMode = RADIO_WIFI;

            // Stop BLE scanning
            stopBleScan();

            // Resume WiFi promiscuous mode
            startProbeCapture();
        }
    }
}

// =============================================================================
// AT Command Interface
// =============================================================================

// Clear the AT response buffer
static void atClearBuffer() {
    g_atBufferLen = 0;
    g_atBuffer[0] = '\0';
}

// Send AT command and wait for response
// Returns true if expected response found, false on timeout
static bool atSendCommand(const char* cmd, const char* expect, uint32_t timeoutMs) {
    atClearBuffer();

    // Flush any pending input
    while (ModemSerial.available()) {
        ModemSerial.read();
    }

    // Send command
    Serial.printf("[AT TX] %s\n", cmd);
    ModemSerial.print(cmd);
    ModemSerial.print("\r\n");

    uint32_t startTime = millis();
    bool found = false;

    while ((millis() - startTime) < timeoutMs && !found) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
            g_atBuffer[g_atBufferLen] = '\0';

            // Check for expected response
            if (expect && strstr(g_atBuffer, expect)) {
                found = true;
                break;
            }

            // Check for error
            if (strstr(g_atBuffer, "ERROR")) {
                Serial.printf("[AT RX] %s\n", g_atBuffer);
                return false;
            }
        }
        delay(10);
    }

    Serial.printf("[AT RX] %s\n", g_atBuffer);
    return found;
}

// Send raw data (for TCP payload)
static void atSendRaw(const char* data, size_t len) {
    Serial.printf("[AT TX RAW] (%zu bytes)\n", len);
    ModemSerial.write((const uint8_t*)data, len);
}

// Wait for specific string in modem output
static bool atWaitFor(const char* expect, uint32_t timeoutMs) {
    atClearBuffer();
    uint32_t startTime = millis();

    while ((millis() - startTime) < timeoutMs) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
            g_atBuffer[g_atBufferLen] = '\0';

            if (strstr(g_atBuffer, expect)) {
                Serial.printf("[AT RX] %s\n", g_atBuffer);
                return true;
            }
        }
        delay(10);
    }

    Serial.printf("[AT RX TIMEOUT] %s\n", g_atBuffer);
    return false;
}

// =============================================================================
// Modem & Network Management
// =============================================================================

// Get signal quality (CSQ) and convert to dBm
static int getSignalQuality() {
    // AT Command: AT+CSQ
    // Purpose: Query signal quality
    // Expected Response: +CSQ: <rssi>,<ber>\r\nOK
    // Timeout: 5000ms
    // Reference: SIM7028 AT Command Manual Section 5.3
    //
    // Note: Must wait for "OK" to ensure complete response is received.
    // The SIM7028 sends "+CSQ: XX,YY" followed by "\r\nOK" and we need
    // the full response to parse the rssi value correctly.

    if (!atSendCommand("AT+CSQ", "OK", 5000)) {
        Serial.println("[NET] CSQ command failed or timed out");
        return -999;
    }

    // Parse +CSQ: rssi,ber from buffer
    // Response format: "+CSQ: 15,99" or "+CSQ:15,99" (with or without space)
    char* ptr = strstr(g_atBuffer, "+CSQ:");
    if (!ptr) {
        Serial.println("[NET] CSQ response not found in buffer");
        return -999;
    }

    int rssi = 99;
    int ber = 99;

    // Try parsing with space first, then without
    if (sscanf(ptr, "+CSQ: %d,%d", &rssi, &ber) != 2) {
        if (sscanf(ptr, "+CSQ:%d,%d", &rssi, &ber) != 2) {
            Serial.printf("[NET] Failed to parse CSQ response: %s\n", ptr);
            return -999;
        }
    }

    Serial.printf("[NET] CSQ raw: rssi=%d, ber=%d\n", rssi, ber);

    // Convert RSSI to dBm
    // 0 = -113 dBm or less
    // 1 = -111 dBm
    // 2-30 = -109 to -53 dBm (2 dBm steps)
    // 31 = -51 dBm or greater
    // 99 = not known or not detectable
    if (rssi == 99) return -999;
    if (rssi == 0) return -113;
    if (rssi == 31) return -51;
    return -113 + (rssi * 2);
}

// Check network registration status
static bool checkNetworkRegistration() {
    // AT Command: AT+CEREG?
    // Purpose: Query EPS network registration status
    // Expected Response: +CEREG: <n>,<stat>\r\nOK
    // Timeout: 5000ms
    // Reference: SIM7028 AT Command Manual Section 7.2

    // Wait for OK (end of response) to ensure we have complete data
    if (!atSendCommand("AT+CEREG?", "OK", 5000)) {
        return false;
    }

    // Parse +CEREG: n,stat from buffer
    char* ptr = strstr(g_atBuffer, "+CEREG:");
    if (!ptr) return false;

    int n = 0, stat = 0;
    // Try parsing with both spaces and without
    if (sscanf(ptr, "+CEREG: %d,%d", &n, &stat) != 2) {
        if (sscanf(ptr, "+CEREG:%d,%d", &n, &stat) != 2) {
            Serial.printf("[NET] Failed to parse CEREG: %s\n", ptr);
            return false;
        }
    }

    Serial.printf("[NET] CEREG status: n=%d, stat=%d\n", n, stat);

    // stat: 1=registered home, 5=registered roaming
    return (stat == 1 || stat == 5);
}

// Initialize modem and establish network connection
static bool initializeNetwork() {
    Serial.println("[NET] Initializing modem...");
    ledSetStatus(LED_STATUS_SEARCHING);

    // Basic modem test with retry loop
    // Modem needs time to initialize after power-on
    bool modemReady = false;
    for (int attempt = 1; attempt <= 5; attempt++) {
        Serial.printf("[NET] Modem AT test attempt %d/5...\n", attempt);
        if (atSendCommand("AT", "OK", 2000)) {
            modemReady = true;
            break;
        }
        Serial.println("[NET] Modem not ready, waiting 2 seconds...");
        delay(2000);
    }

    if (!modemReady) {
        Serial.println("[NET] Modem not responding after 5 attempts");
        ledSetStatus(LED_STATUS_ERROR);
        return false;
    }

    // Disable echo
    // AT Command: ATE0
    // Purpose: Disable command echo
    // Expected Response: OK
    // Timeout: 2000ms
    atSendCommand("ATE0", "OK", 2000);

    // Check SIM status
    // AT Command: AT+CPIN?
    // Purpose: Check SIM card status
    // Expected Response: +CPIN: READY
    // Timeout: 5000ms
    if (!atSendCommand("AT+CPIN?", "READY", 5000)) {
        Serial.println("[NET] SIM not ready");
        ledSetStatus(LED_STATUS_ERROR);
        return false;
    }

    // Set NB-IoT only mode
    // AT Command: AT+CNMP=38
    // Purpose: Set preferred network mode to NB-IoT only
    // Expected Response: OK
    // Timeout: 5000ms
    atSendCommand("AT+CNMP=38", "OK", 5000);

    // Wait for network registration
    Serial.println("[NET] Waiting for network registration...");
    uint32_t startTime = millis();
    while ((millis() - startTime) < NETWORK_INIT_TIMEOUT_MS) {
        esp_task_wdt_reset();  // Feed watchdog - network init can take 2+ minutes
        ledUpdate();  // Keep LED animation running
        if (checkNetworkRegistration()) {
            Serial.println("[NET] Registered to network");
            break;
        }
        Serial.print(".");
        delay(5000);
    }

    if (!checkNetworkRegistration()) {
        Serial.println("\n[NET] Registration timeout");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    // Get signal quality
    g_cellRssi = getSignalQuality();
    Serial.printf("[NET] Signal: %d dBm\n", g_cellRssi);

    // Close any existing network connection
    // AT Command: AT+NETCLOSE
    // Purpose: Close network connection to clean state
    // Expected Response: OK or +NETCLOSE
    // Timeout: 5000ms
    atSendCommand("AT+NETCLOSE", "OK", 5000);
    delay(1000);

    // Configure PDP context with Hologram APN
    // AT Command: AT+CGDCONT=0,"IP","hologram"
    // Purpose: Define PDP context 0 with Hologram APN
    // Expected Response: OK
    // Timeout: 5000ms
    atSendCommand("AT+CGDCONT=0,\"IP\",\"hologram\"", "OK", 5000);

    // Attach to packet domain
    // AT Command: AT+CGATT=1
    // Purpose: Attach to PS domain
    // Expected Response: OK
    // Timeout: 30000ms
    if (!atSendCommand("AT+CGATT=1", "OK", 30000)) {
        Serial.println("[NET] PS attach failed");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    // Open network connection
    // AT Command: AT+NETOPEN
    // Purpose: Open IP network connection
    // Expected Response: +NETOPEN: 0
    // Timeout: 60000ms
    // Note: This is CRITICAL - registration alone does not enable data
    if (!atSendCommand("AT+NETOPEN", "+NETOPEN: 0", 60000)) {
        // Check if already open
        if (!strstr(g_atBuffer, "Network is already opened")) {
            Serial.println("[NET] NETOPEN failed");
            ledSetStatus(LED_STATUS_SEARCHING);
            return false;
        }
    }

    // Verify IP address
    // AT Command: AT+IPADDR
    // Purpose: Query assigned IP address
    // Expected Response: +IPADDR: x.x.x.x\r\nOK
    // Timeout: 5000ms
    if (!atSendCommand("AT+IPADDR", "OK", 5000)) {
        Serial.println("[NET] No IP address assigned");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    // Make sure we actually got an IP (not an error)
    if (!strstr(g_atBuffer, "+IPADDR:")) {
        Serial.println("[NET] IPADDR response missing");
        ledSetStatus(LED_STATUS_SEARCHING);
        return false;
    }

    Serial.println("[NET] Network ready");
    g_networkReady = true;
    ledSetStatus(LED_STATUS_CONNECTED);  // Set LED to CYAN when network is ready
    return true;
}

// =============================================================================
// HTTP POST via TCP
// =============================================================================

// Check response for OTA trigger flag
static bool checkOtaTrigger(const char* response) {
    // Look for "ota":true or "ota": true in JSON response
    return (strstr(response, "\"ota\":true") != NULL ||
            strstr(response, "\"ota\": true") != NULL);
}

// Send reading to backend via HTTP POST over TCP
// Quality fields: overflowCount=uniques dropped, ageSeconds=how old is this reading (0=live)
static bool sendReading(const char* timestamp, uint32_t impressions, uint32_t unique,
                        int probeRssiAvg, int probeRssiMin, int probeRssiMax, int cellRssi,
                        uint32_t dwell_0_1, uint32_t dwell_1_5, uint32_t dwell_5_10, uint32_t dwell_10plus,
                        uint32_t rssi_immediate, uint32_t rssi_near, uint32_t rssi_far, uint32_t rssi_remote,
                        uint32_t bleImpressions, uint32_t bleUnique,
                        uint32_t bleApple, uint32_t bleOther, int bleRssiAvg,
                        uint16_t overflowCount, uint32_t ageSeconds) {
    Serial.printf("[HTTP] WiFi: t=%s, i=%lu, u=%lu\n", timestamp, impressions, unique);
    Serial.printf("[HTTP]   probe_rssi: avg=%d min=%d max=%d, cell_rssi=%d\n",
                  probeRssiAvg, probeRssiMin, probeRssiMax, cellRssi);
    Serial.printf("[HTTP]   dwell: 0-1=%lu, 1-5=%lu, 5-10=%lu, 10+=%lu\n",
                  dwell_0_1, dwell_1_5, dwell_5_10, dwell_10plus);
    Serial.printf("[HTTP]   rssi_zones: imm=%lu, near=%lu, far=%lu, remote=%lu\n",
                  rssi_immediate, rssi_near, rssi_far, rssi_remote);
    Serial.printf("[HTTP] BLE: i=%lu, u=%lu, Apple=%lu, Other=%lu, rssi_avg=%d\n",
                  bleImpressions, bleUnique, bleApple, bleOther, bleRssiAvg);
    Serial.printf("[HTTP] Quality: of=%u, cd=%u, sf=%u, age=%lu\n",
                  overflowCount, g_cacheCount, g_sendFailures, ageSeconds);

    ledSetStatus(LED_STATUS_TRANSMITTING);  // Orange pulsing during send

    // Build JSON payload with WiFi probes + BLE device counts (Apple vs Other)
    // Quality fields: of=overflow, cd=cache_depth, sf=send_failures, age=seconds old
    char jsonPayload[900];
    snprintf(jsonPayload, sizeof(jsonPayload),
             "{\"d\":\"%s\",\"t\":\"%s\",\"i\":%lu,\"u\":%lu,"
             "\"probe_rssi_avg\":%d,\"probe_rssi_min\":%d,\"probe_rssi_max\":%d,\"cell_rssi\":%d,"
             "\"dwell_0_1\":%lu,\"dwell_1_5\":%lu,\"dwell_5_10\":%lu,\"dwell_10plus\":%lu,"
             "\"rssi_immediate\":%lu,\"rssi_near\":%lu,\"rssi_far\":%lu,\"rssi_remote\":%lu,"
             "\"ble_i\":%lu,\"ble_u\":%lu,\"ble_apple\":%lu,\"ble_other\":%lu,\"ble_rssi_avg\":%d,"
             "\"of\":%u,\"cd\":%u,\"sf\":%u,\"age\":%lu,"
             "\"ts\":%d,\"bt\":%lu}",
             DEVICE_ID, timestamp, impressions, unique,
             probeRssiAvg, probeRssiMin, probeRssiMax, cellRssi,
             dwell_0_1, dwell_1_5, dwell_5_10, dwell_10plus,
             rssi_immediate, rssi_near, rssi_far, rssi_remote,
             bleImpressions, bleUnique, bleApple, bleOther, bleRssiAvg,
             overflowCount, g_cacheCount, g_sendFailures, ageSeconds,
             g_timeSynced ? 1 : 0, g_bootTimestamp);

    size_t jsonLen = strlen(jsonPayload);

    // Build HTTP request
    char httpRequest[1100];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        BACKEND_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    Serial.printf("[HTTP] Connecting to %s:%d\n", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[HTTP] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        g_lastSendSuccess = false;
        ledSetStatus(LED_STATUS_SEND_FAILED);
        return false;
    }

    Serial.println("[HTTP] Connected");
    delay(500);

    // Send data
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[HTTP] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        g_lastSendSuccess = false;
        ledSetStatus(LED_STATUS_SEND_FAILED);
        return false;
    }

    // Send HTTP request data
    atSendRaw(httpRequest, httpLen);

    // Wait for send confirmation
    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[HTTP] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        g_lastSendSuccess = false;
        ledSetStatus(LED_STATUS_SEND_FAILED);
        return false;
    }

    // Wait for HTTP response
    delay(2000);

    // Read response data
    atClearBuffer();
    uint32_t readStart = millis();
    while ((millis() - readStart) < 5000) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(100);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    if (g_atBufferLen > 0) {
        Serial.printf("[HTTP] Response: %s\n", g_atBuffer);
    }

    // Check for HTTP success (200 OK or 201 Created)
    bool success = (strstr(g_atBuffer, "200") != NULL ||
                    strstr(g_atBuffer, "201") != NULL);

    // Check for OTA trigger in response
    if (success && checkOtaTrigger(g_atBuffer)) {
        Serial.println("[HTTPS] OTA update requested by backend");
        g_otaRequested = true;
    }

    // Check for remote command in response (same as heartbeat)
    if (success) {
        char* jsonBody = strstr(g_atBuffer, "\r\n\r\n");
        if (!jsonBody) jsonBody = strstr(g_atBuffer, "{"); // Fallback

        if (jsonBody) {
            char* cmdStart = strstr(jsonBody, "\"command\":\"");
            if (cmdStart) {
                cmdStart += 11; // Skip past "command":"
                char* cmdEnd = strchr(cmdStart, '"');

                if (cmdEnd && (cmdEnd - cmdStart) < 31) { // Bounds check
                    char command[32] = {0};
                    size_t cmdLen = cmdEnd - cmdStart;
                    memcpy(command, cmdStart, cmdLen);

                    Serial.printf("[COMMAND] Received in reading response: %s\n", command);

                    if (strcmp(command, "reboot") == 0) {
                        Serial.println("[COMMAND] Reboot scheduled");
                        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
                        delay(1000);
                        ESP.restart();
                    } else if (strcmp(command, "send_now") == 0) {
                        Serial.println("[COMMAND] Force send requested");
                        g_forceSendRequested = true;
                    } else if (strcmp(command, "geolocate") == 0) {
                        Serial.println("[COMMAND] Remote geolocation requested");
                        g_geolocationPending = true;
                    } else if (strcmp(command, "ota_check") == 0) {
                        Serial.println("[COMMAND] OTA update check requested");
                        triggerOtaCheck();
                    } else {
                        Serial.printf("[COMMAND] Unknown command: %s\n", command);
                    }
                }
            }
        }
    }

    // Close TCP connection
    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    if (success) {
        Serial.println("[HTTP] Success");
        g_lastSendSuccess = true;
        g_sendFailures = 0;  // Reset consecutive failure count on success
        ledSetStatus(LED_STATUS_SEND_SUCCESS);  // Green for 3 sec, then cyan

        // OTA rollback protection: After first successful send, mark this
        // firmware as valid. If device had been flashed with bad firmware,
        // ESP32 would have rebooted back to previous working firmware already.
        if (!g_otaConfirmed) {
            esp_ota_mark_app_valid_cancel_rollback();
            g_otaConfirmed = true;
            Serial.println("[OTA] Firmware confirmed valid - rollback disabled");
        }
    } else {
        Serial.println("[HTTP] Response not OK");
        g_lastSendSuccess = false;
        g_sendFailures++;    // Increment consecutive failure count
        ledSetStatus(LED_STATUS_SEND_FAILED);   // Blue slow blink
    }

    return success;
}

// =============================================================================
// Heartbeat Function
// =============================================================================

// Send heartbeat to backend - daily check-in even with zero traffic
static bool sendHeartbeat() {
    Serial.println("[HEARTBEAT] Sending heartbeat...");

    // Get current cellular signal
    int cellRssi = getSignalQuality();
    uint32_t uptimeSec = millis() / 1000;

    Serial.printf("[HEARTBEAT] Device: %s, Version: %s, Uptime: %lu sec, RSSI: %d dBm\n",
                  DEVICE_ID, FIRMWARE_VERSION, uptimeSec, cellRssi);

    // Build JSON payload
    // Format: {"d":"JBNB0001","v":"2.8","uptime":86400,"cell_rssi":-85}
    char jsonPayload[128];
    snprintf(jsonPayload, sizeof(jsonPayload),
             "{\"d\":\"%s\",\"v\":\"%s\",\"uptime\":%lu,\"cell_rssi\":%d}",
             DEVICE_ID, FIRMWARE_VERSION, uptimeSec, cellRssi);

    size_t jsonLen = strlen(jsonPayload);

    // Build HTTP request
    char httpRequest[384];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        HEARTBEAT_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    Serial.printf("[HEARTBEAT] Connecting to %s:%d\n", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[HEARTBEAT] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    Serial.println("[HEARTBEAT] Connected");
    delay(500);

    // Send data
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[HEARTBEAT] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Send HTTP request data
    atSendRaw(httpRequest, httpLen);

    // Wait for send confirmation
    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[HEARTBEAT] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Wait for HTTP response
    delay(2000);

    // Read response data
    atClearBuffer();
    uint32_t readStart = millis();
    while ((millis() - readStart) < 5000) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(100);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    if (g_atBufferLen > 0) {
        Serial.printf("[HEARTBEAT] Response: %s\n", g_atBuffer);
    }

    // Check for HTTP success
    bool success = (strstr(g_atBuffer, "200") != NULL ||
                    strstr(g_atBuffer, "201") != NULL);

    // Parse server_time BEFORE closing connection (atSendCommand clears g_atBuffer!)
    if (success) {
        Serial.println("[HEARTBEAT] Success");

        // Parse server_time for timestamp synchronization
        Serial.printf("[TIME DEBUG] Buffer len: %d\n", g_atBufferLen);
        char* jsonBody = strstr(g_atBuffer, "\r\n\r\n");
        if (!jsonBody) {
            Serial.println("[TIME DEBUG] No \\r\\n\\r\\n found, looking for {");
            jsonBody = strstr(g_atBuffer, "{");
        }

        if (jsonBody) {
            Serial.printf("[TIME DEBUG] JSON body found at offset %ld\n", jsonBody - g_atBuffer);
            // Look for server_time in response (ISO 8601 format)
            char* timeStart = strstr(jsonBody, "\"server_time\":\"");
            if (timeStart) {
                Serial.println("[TIME DEBUG] Found server_time key");
                timeStart += 15;  // Skip past "server_time":"
                char* timeEnd = strchr(timeStart, '"');
                if (timeEnd && (timeEnd - timeStart) < 40) {
                    char serverTime[48] = {0};
                    memcpy(serverTime, timeStart, timeEnd - timeStart);

                    // Parse ISO 8601: "2026-01-26T12:30:00+00:00" or "2026-01-26T12:30:00.123456+00:00"
                    int year, month, day, hour, minute, second;
                    if (sscanf(serverTime, "%d-%d-%dT%d:%d:%d", &year, &month, &day, &hour, &minute, &second) == 6) {
                        // Convert to Unix timestamp manually (avoids mktime timezone issues)
                        // Days from year 1970 to start of given year
                        uint32_t days = 0;
                        for (int y = 1970; y < year; y++) {
                            days += (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)) ? 366 : 365;
                        }
                        // Days in months of current year
                        static const int daysInMonth[] = {31,28,31,30,31,30,31,31,30,31,30,31};
                        bool isLeap = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
                        for (int m = 0; m < month - 1; m++) {
                            days += daysInMonth[m];
                            if (m == 1 && isLeap) days++; // Feb in leap year
                        }
                        days += day - 1;

                        uint32_t serverEpoch = days * 86400UL + hour * 3600UL + minute * 60UL + second;
                        uint32_t deviceUptime = millis() / 1000;
                        g_bootTimestamp = serverEpoch - deviceUptime;

                        Serial.printf("[TIME] Parsed: %04d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second);
                        Serial.printf("[TIME] Server epoch: %lu, uptime: %lu\n", serverEpoch, deviceUptime);
                        Serial.printf("[TIME] Boot timestamp set to: %lu\n", g_bootTimestamp);
                        g_timeSynced = true;
                    } else {
                        Serial.printf("[TIME] Failed to parse: %s\n", serverTime);
                    }
                } else {
                    Serial.println("[TIME DEBUG] Could not find end quote for server_time value");
                }
            } else {
                Serial.println("[TIME DEBUG] server_time key not found in response");
            }

            // Check for remote command in response (reuse jsonBody from time sync)
            char* cmdStart = strstr(jsonBody, "\"command\":\"");
            if (cmdStart) {
                cmdStart += 11; // Skip past "command":"
                char* cmdEnd = strchr(cmdStart, '"');

                if (cmdEnd && (cmdEnd - cmdStart) < 31) { // Bounds check
                    char command[32] = {0};
                    size_t cmdLen = cmdEnd - cmdStart;
                    memcpy(command, cmdStart, cmdLen);

                    Serial.printf("[COMMAND] Received: %s\n", command);

                    if (strcmp(command, "reboot") == 0) {
                        Serial.println("[COMMAND] Reboot scheduled - closing connection first");
                        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
                        delay(1000);
                        Serial.println("[COMMAND] Executing reboot now...");
                        ESP.restart();
                    } else if (strcmp(command, "send_now") == 0) {
                        Serial.println("[COMMAND] Force send requested");
                        g_forceSendRequested = true;
                    } else if (strcmp(command, "geolocate") == 0) {
                        Serial.println("[COMMAND] Remote geolocation requested");
                        g_geolocationPending = true;
                    } else if (strcmp(command, "ota_check") == 0) {
                        Serial.println("[COMMAND] OTA update check requested");
                        triggerOtaCheck();
                    } else if (strcmp(command, "fetch_config") == 0) {
                        Serial.println("[COMMAND] Config fetch requested");
                        g_configFetchPending = true;
                    } else {
                        Serial.printf("[COMMAND] Unknown command: %s\n", command);
                    }
                }
            }

            // Check for config_version in response - if higher than local, schedule config fetch
            char* configVerStart = strstr(jsonBody, "\"config_version\":");
            if (configVerStart) {
                configVerStart += 17;  // Skip past "config_version":
                uint32_t serverConfigVersion = (uint32_t)atol(configVerStart);
                if (serverConfigVersion > g_configVersion) {
                    Serial.printf("[CONFIG] Server config v%lu > local v%lu - fetch scheduled\n",
                                  serverConfigVersion, g_configVersion);
                    g_configFetchPending = true;
                }
            }
        } else {
            Serial.println("[TIME DEBUG] No JSON body found in response");
        }

        // OTA rollback protection: After first successful communication, mark firmware valid
        if (!g_otaConfirmed) {
            esp_ota_mark_app_valid_cancel_rollback();
            g_otaConfirmed = true;
            Serial.println("[OTA] Firmware confirmed valid - rollback disabled");
        }

        // Schedule OTA check after successful heartbeat (if not already in progress)
        // This provides automatic daily update checking
        if (g_otaDelta.state == OTA_DELTA_IDLE) {
            g_otaDelta.checkPending = true;
            Serial.println("[HEARTBEAT] OTA check scheduled (daily)");
        }
    } else {
        Serial.println("[HEARTBEAT] Failed");
    }

    // Close TCP connection (after parsing is complete)
    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    return success;
}

// =============================================================================
// Remote Configuration Fetch (v5.4)
// =============================================================================

// Config endpoint path
#define CONFIG_PATH "/api/config/"

// Fetch device config from backend and apply thresholds
static bool fetchAndApplyConfig() {
    Serial.println("[CONFIG] Fetching remote configuration...");

    // Build config path with device ID
    char configPath[64];
    snprintf(configPath, sizeof(configPath), CONFIG_PATH "%s", DEVICE_ID);

    // Build HTTP request
    char request[512];
    int requestLen = snprintf(request, sizeof(request),
        "GET %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Connection: close\r\n"
        "\r\n",
        configPath, BACKEND_HOST, BACKEND_PORT, AUTH_TOKEN);

    Serial.printf("[CONFIG] Connecting to %s:%d\n", BACKEND_HOST, BACKEND_PORT);

    // Open TCP connection
    char cmd[128];
    snprintf(cmd, sizeof(cmd), "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);
    if (!atSendCommand(cmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[CONFIG] TCP connect failed");
        return false;
    }

    Serial.println("[CONFIG] Connected, sending request");

    // Send data
    snprintf(cmd, sizeof(cmd), "AT+CIPSEND=0,%d", requestLen);
    if (!atSendCommand(cmd, ">", 5000)) {
        Serial.println("[CONFIG] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Send HTTP request
    ModemSerial.write((uint8_t*)request, requestLen);

    // Wait for response
    delay(500);
    uint32_t responseStart = millis();
    g_atBufferLen = 0;
    while ((millis() - responseStart) < 15000 && g_atBufferLen < (sizeof(g_atBuffer) - 1)) {
        if (ModemSerial.available()) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(10);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    // Close connection first
    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    // Check for HTTP success
    if (strstr(g_atBuffer, "200") == NULL) {
        Serial.println("[CONFIG] HTTP request failed");
        return false;
    }

    Serial.println("[CONFIG] Response received, parsing...");

    // Find JSON body
    char* jsonBody = strstr(g_atBuffer, "\r\n\r\n");
    if (!jsonBody) {
        jsonBody = strstr(g_atBuffer, "{");
    }
    if (!jsonBody) {
        Serial.println("[CONFIG] No JSON body found");
        return false;
    }

    // Parse config values (simple JSON parsing)
    // config_version
    char* ptr = strstr(jsonBody, "\"config_version\":");
    if (ptr) {
        ptr += 17;
        g_configVersion = (uint32_t)atol(ptr);
        Serial.printf("[CONFIG] Version: %lu\n", g_configVersion);
    }

    // report_interval_ms - note: not applied in this MVP, would require NVS persistence
    ptr = strstr(jsonBody, "\"report_interval_ms\":");
    if (ptr) {
        ptr += 21;
        uint32_t interval = (uint32_t)atol(ptr);
        Serial.printf("[CONFIG] Report interval: %lu ms (note: requires reflash to change)\n", interval);
        // Future: store in NVS and use dynamic interval
    }

    // RSSI thresholds
    ptr = strstr(jsonBody, "\"rssi_immediate_threshold\":");
    if (ptr) {
        ptr += 27;
        g_rssiImmediateThreshold = atoi(ptr);
        Serial.printf("[CONFIG] RSSI immediate: %d dBm\n", g_rssiImmediateThreshold);
    }

    ptr = strstr(jsonBody, "\"rssi_near_threshold\":");
    if (ptr) {
        ptr += 22;
        g_rssiNearThreshold = atoi(ptr);
        Serial.printf("[CONFIG] RSSI near: %d dBm\n", g_rssiNearThreshold);
    }

    ptr = strstr(jsonBody, "\"rssi_far_threshold\":");
    if (ptr) {
        ptr += 21;
        g_rssiFarThreshold = atoi(ptr);
        Serial.printf("[CONFIG] RSSI far: %d dBm\n", g_rssiFarThreshold);
    }

    // Dwell thresholds
    ptr = strstr(jsonBody, "\"dwell_short_threshold\":");
    if (ptr) {
        ptr += 24;
        g_dwellShortThreshold = (uint8_t)atoi(ptr);
        Serial.printf("[CONFIG] Dwell short: %u min\n", g_dwellShortThreshold);
    }

    ptr = strstr(jsonBody, "\"dwell_medium_threshold\":");
    if (ptr) {
        ptr += 25;
        g_dwellMediumThreshold = (uint8_t)atoi(ptr);
        Serial.printf("[CONFIG] Dwell medium: %u min\n", g_dwellMediumThreshold);
    }

    ptr = strstr(jsonBody, "\"dwell_long_threshold\":");
    if (ptr) {
        ptr += 23;
        g_dwellLongThreshold = (uint8_t)atoi(ptr);
        Serial.printf("[CONFIG] Dwell long: %u min\n", g_dwellLongThreshold);
    }

    Serial.println("[CONFIG] Configuration applied successfully");
    return true;
}

// =============================================================================
// Delta OTA Functions (NB-IoT Remote Update)
// =============================================================================

// CRC16-CCITT calculation (same as backend uses)
// Polynomial: 0x1021, Initial: 0xFFFF
static uint16_t crc16_ccitt(const uint8_t* data, size_t len) {
    uint16_t crc = 0xFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= ((uint16_t)data[i] << 8);
        for (int j = 0; j < 8; j++) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ 0x1021;
            } else {
                crc <<= 1;
            }
        }
    }
    return crc;
}

// Base64 decoding table
static const int8_t b64_decode_table[256] = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,
    52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,
    15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
    -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
    41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
};

// Base64 decode function - returns decoded length, -1 on error
static int base64_decode(const char* input, size_t inputLen, uint8_t* output, size_t maxOutput) {
    size_t outLen = 0;
    uint32_t buf = 0;
    int bufBits = 0;

    for (size_t i = 0; i < inputLen; i++) {
        char c = input[i];
        if (c == '=') break;  // Padding
        if (c == '\n' || c == '\r' || c == ' ') continue;  // Skip whitespace

        int8_t val = b64_decode_table[(uint8_t)c];
        if (val < 0) return -1;  // Invalid character

        buf = (buf << 6) | val;
        bufBits += 6;

        if (bufBits >= 8) {
            bufBits -= 8;
            if (outLen >= maxOutput) return -1;  // Output buffer full
            output[outLen++] = (buf >> bufBits) & 0xFF;
        }
    }

    return (int)outLen;
}

// Initialize SPIFFS for patch storage
static bool initSpiffs() {
    if (g_spiffsReady) return true;

    Serial.println("[OTA-DELTA] Initializing SPIFFS...");
    if (!SPIFFS.begin(true)) {  // true = format if mount fails
        Serial.println("[OTA-DELTA] SPIFFS mount failed!");
        return false;
    }

    g_spiffsReady = true;
    Serial.printf("[OTA-DELTA] SPIFFS mounted. Total: %u, Used: %u\n",
                  SPIFFS.totalBytes(), SPIFFS.usedBytes());
    return true;
}

// Save OTA state to NVS for crash recovery
static void otaSaveState() {
    g_otaNvs.begin(OTA_NVS_NAMESPACE, false);
    g_otaNvs.putUChar("state", (uint8_t)g_otaDelta.state);
    g_otaNvs.putString("target_ver", g_otaDelta.targetVersion);
    g_otaNvs.putString("current_ver", g_otaDelta.currentVersion);
    g_otaNvs.putUInt("patch_size", g_otaDelta.patchSize);
    g_otaNvs.putUShort("total_chunks", g_otaDelta.totalChunks);
    g_otaNvs.putUShort("chunks_rcvd", g_otaDelta.chunksReceived);
    g_otaNvs.putString("sha256", g_otaDelta.patchSha256);
    g_otaNvs.end();
    Serial.printf("[OTA-DELTA] State saved: state=%d, chunks=%d/%d\n",
                  g_otaDelta.state, g_otaDelta.chunksReceived, g_otaDelta.totalChunks);
}

// Load OTA state from NVS (for recovery after crash/reboot)
static void otaLoadState() {
    g_otaNvs.begin(OTA_NVS_NAMESPACE, true);  // true = read-only
    g_otaDelta.state = (OtaDeltaState)g_otaNvs.getUChar("state", OTA_DELTA_IDLE);

    String targetVer = g_otaNvs.getString("target_ver", "");
    strncpy(g_otaDelta.targetVersion, targetVer.c_str(), sizeof(g_otaDelta.targetVersion) - 1);

    String currentVer = g_otaNvs.getString("current_ver", "");
    strncpy(g_otaDelta.currentVersion, currentVer.c_str(), sizeof(g_otaDelta.currentVersion) - 1);

    g_otaDelta.patchSize = g_otaNvs.getUInt("patch_size", 0);
    g_otaDelta.totalChunks = g_otaNvs.getUShort("total_chunks", 0);
    g_otaDelta.chunksReceived = g_otaNvs.getUShort("chunks_rcvd", 0);

    String sha256 = g_otaNvs.getString("sha256", "");
    strncpy(g_otaDelta.patchSha256, sha256.c_str(), sizeof(g_otaDelta.patchSha256) - 1);

    g_otaNvs.end();

    if (g_otaDelta.state != OTA_DELTA_IDLE) {
        Serial.printf("[OTA-DELTA] Recovered state: state=%d, target=%s, chunks=%d/%d\n",
                      g_otaDelta.state, g_otaDelta.targetVersion,
                      g_otaDelta.chunksReceived, g_otaDelta.totalChunks);
    }
}

// Clear OTA state (reset to idle)
static void otaClearState() {
    g_otaNvs.begin(OTA_NVS_NAMESPACE, false);
    g_otaNvs.clear();
    g_otaNvs.end();

    memset(&g_otaDelta, 0, sizeof(g_otaDelta));
    g_otaDelta.state = OTA_DELTA_IDLE;

    // Remove patch file if exists
    if (g_spiffsReady && SPIFFS.exists(OTA_PATCH_FILE)) {
        SPIFFS.remove(OTA_PATCH_FILE);
        Serial.println("[OTA-DELTA] Removed old patch file");
    }

    Serial.println("[OTA-DELTA] State cleared");
}

// Check for OTA update availability
// POST /api/ota/check {"device_id":"JBNB0001","fw_version":"4.6"}
// Response: {"update_available":true,"target":"4.7","patch_size":18432,"chunk_count":36,"sha256":"abc..."}
static bool otaCheckForUpdate() {
    Serial.printf("[OTA-DELTA] Checking for updates (current: v%s)...\n", FIRMWARE_VERSION);

    // Build JSON payload
    char jsonPayload[128];
    snprintf(jsonPayload, sizeof(jsonPayload),
             "{\"device_id\":\"%s\",\"fw_version\":\"%s\"}",
             DEVICE_ID, FIRMWARE_VERSION);

    size_t jsonLen = strlen(jsonPayload);

    // Build HTTP request
    char httpRequest[384];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        OTA_CHECK_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[OTA-DELTA] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    delay(500);

    // Send request
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[OTA-DELTA] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    atSendRaw(httpRequest, httpLen);

    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[OTA-DELTA] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Wait for response
    delay(2000);

    atClearBuffer();
    uint32_t readStart = millis();
    while ((millis() - readStart) < 5000) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(100);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    // Check HTTP status
    if (!strstr(g_atBuffer, "200")) {
        Serial.println("[OTA-DELTA] Check request failed (not 200)");
        return false;
    }

    // Parse JSON response
    char* jsonBody = strstr(g_atBuffer, "\r\n\r\n");
    if (!jsonBody) jsonBody = strstr(g_atBuffer, "{");
    if (!jsonBody) {
        Serial.println("[OTA-DELTA] No JSON body in response");
        return false;
    }

    // Check if update is available
    if (!strstr(jsonBody, "\"update_available\":true") &&
        !strstr(jsonBody, "\"update_available\": true")) {
        Serial.println("[OTA-DELTA] No update available");
        return false;
    }

    // Parse target version
    char* targetStart = strstr(jsonBody, "\"target\":\"");
    if (!targetStart) {
        Serial.println("[OTA-DELTA] Missing target version");
        return false;
    }
    targetStart += 10;
    char* targetEnd = strchr(targetStart, '"');
    if (!targetEnd || (targetEnd - targetStart) >= (int)sizeof(g_otaDelta.targetVersion)) {
        Serial.println("[OTA-DELTA] Invalid target version");
        return false;
    }
    memcpy(g_otaDelta.targetVersion, targetStart, targetEnd - targetStart);
    g_otaDelta.targetVersion[targetEnd - targetStart] = '\0';

    // Parse patch_size
    char* sizeStart = strstr(jsonBody, "\"patch_size\":");
    if (sizeStart) {
        g_otaDelta.patchSize = atoi(sizeStart + 13);
    }

    // Parse chunk_count
    char* chunkStart = strstr(jsonBody, "\"chunk_count\":");
    if (chunkStart) {
        g_otaDelta.totalChunks = atoi(chunkStart + 14);
    }

    // Parse sha256
    char* shaStart = strstr(jsonBody, "\"sha256\":\"");
    if (shaStart) {
        shaStart += 10;
        char* shaEnd = strchr(shaStart, '"');
        if (shaEnd && (shaEnd - shaStart) < (int)sizeof(g_otaDelta.patchSha256)) {
            memcpy(g_otaDelta.patchSha256, shaStart, shaEnd - shaStart);
            g_otaDelta.patchSha256[shaEnd - shaStart] = '\0';
        }
    }

    // Store current version
    strncpy(g_otaDelta.currentVersion, FIRMWARE_VERSION, sizeof(g_otaDelta.currentVersion) - 1);

    Serial.printf("[OTA-DELTA] Update available: v%s -> v%s\n",
                  FIRMWARE_VERSION, g_otaDelta.targetVersion);
    Serial.printf("[OTA-DELTA]   Patch size: %lu bytes, %d chunks\n",
                  g_otaDelta.patchSize, g_otaDelta.totalChunks);
    Serial.printf("[OTA-DELTA]   SHA256: %.16s...\n", g_otaDelta.patchSha256);

    return true;
}

// Download a single chunk of the patch
// GET /api/ota/chunk?device_id=JBNB0001&from=4.6&to=4.7&chunk=N
// Response: {"chunk":N,"data":"base64...","crc":1234,"final":false}
static bool otaDownloadChunk(uint16_t chunkNum) {
    Serial.printf("[OTA-DELTA] Downloading chunk %d/%d...\n",
                  chunkNum + 1, g_otaDelta.totalChunks);

    // Build HTTP GET request with query parameters
    char httpRequest[384];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "GET %s?device_id=%s&from=%s&to=%s&chunk=%d HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Connection: close\r\n"
        "\r\n",
        OTA_CHUNK_PATH, DEVICE_ID, g_otaDelta.currentVersion,
        g_otaDelta.targetVersion, chunkNum,
        BACKEND_HOST, BACKEND_PORT, AUTH_TOKEN);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[OTA-DELTA] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    delay(300);

    // Send request
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[OTA-DELTA] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    atSendRaw(httpRequest, httpLen);

    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[OTA-DELTA] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Wait for response (chunks can take a moment)
    delay(2000);

    // Use a larger buffer for chunk data (base64 encoded 512 bytes = ~700 chars)
    static char chunkBuffer[1024];
    size_t chunkBufLen = 0;

    uint32_t readStart = millis();
    while ((millis() - readStart) < 8000 && chunkBufLen < sizeof(chunkBuffer) - 1) {
        while (ModemSerial.available() && chunkBufLen < sizeof(chunkBuffer) - 1) {
            char c = ModemSerial.read();
            chunkBuffer[chunkBufLen++] = c;
        }
        delay(50);
    }
    chunkBuffer[chunkBufLen] = '\0';

    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    // Check HTTP status
    if (!strstr(chunkBuffer, "200")) {
        Serial.println("[OTA-DELTA] Chunk request failed (not 200)");
        return false;
    }

    // Find JSON body
    char* jsonBody = strstr(chunkBuffer, "\r\n\r\n");
    if (!jsonBody) jsonBody = strstr(chunkBuffer, "{");
    if (!jsonBody) {
        Serial.println("[OTA-DELTA] No JSON body in chunk response");
        return false;
    }

    // Parse chunk number (verify it matches)
    char* chunkNumStart = strstr(jsonBody, "\"chunk\":");
    if (!chunkNumStart) {
        Serial.println("[OTA-DELTA] Missing chunk number in response");
        return false;
    }
    int receivedChunk = atoi(chunkNumStart + 8);
    if (receivedChunk != chunkNum) {
        Serial.printf("[OTA-DELTA] Chunk mismatch: expected %d, got %d\n", chunkNum, receivedChunk);
        return false;
    }

    // Parse CRC
    char* crcStart = strstr(jsonBody, "\"crc\":");
    if (!crcStart) {
        Serial.println("[OTA-DELTA] Missing CRC in response");
        return false;
    }
    uint16_t expectedCrc = (uint16_t)atoi(crcStart + 6);

    // Parse base64 data
    char* dataStart = strstr(jsonBody, "\"data\":\"");
    if (!dataStart) {
        Serial.println("[OTA-DELTA] Missing data in response");
        return false;
    }
    dataStart += 8;
    char* dataEnd = strchr(dataStart, '"');
    if (!dataEnd) {
        Serial.println("[OTA-DELTA] Malformed data field");
        return false;
    }

    size_t b64Len = dataEnd - dataStart;

    // Decode base64
    static uint8_t decodedData[OTA_CHUNK_SIZE + 16];  // Small buffer for one chunk
    int decodedLen = base64_decode(dataStart, b64Len, decodedData, sizeof(decodedData));
    if (decodedLen < 0) {
        Serial.println("[OTA-DELTA] Base64 decode failed");
        return false;
    }

    // Verify CRC
    uint16_t calculatedCrc = crc16_ccitt(decodedData, decodedLen);
    if (calculatedCrc != expectedCrc) {
        Serial.printf("[OTA-DELTA] CRC mismatch: expected 0x%04X, got 0x%04X\n",
                      expectedCrc, calculatedCrc);
        return false;
    }

    // Append to patch file
    File patchFile = SPIFFS.open(OTA_PATCH_FILE, chunkNum == 0 ? "w" : "a");
    if (!patchFile) {
        Serial.println("[OTA-DELTA] Failed to open patch file");
        return false;
    }

    size_t written = patchFile.write(decodedData, decodedLen);
    patchFile.close();

    if (written != (size_t)decodedLen) {
        Serial.printf("[OTA-DELTA] Write failed: %d/%d bytes\n", written, decodedLen);
        return false;
    }

    Serial.printf("[OTA-DELTA] Chunk %d: %d bytes, CRC OK\n", chunkNum, decodedLen);

    return true;
}

// Verify the complete patch file SHA256
static bool otaVerifyPatch() {
    Serial.println("[OTA-DELTA] Verifying patch SHA256...");

    File patchFile = SPIFFS.open(OTA_PATCH_FILE, "r");
    if (!patchFile) {
        Serial.println("[OTA-DELTA] Cannot open patch file for verification");
        return false;
    }

    // Calculate SHA256
    mbedtls_sha256_context sha256_ctx;
    mbedtls_sha256_init(&sha256_ctx);
    mbedtls_sha256_starts(&sha256_ctx, 0);  // 0 = SHA256 (not SHA224)

    uint8_t readBuf[256];
    size_t totalRead = 0;

    while (patchFile.available()) {
        size_t bytesRead = patchFile.read(readBuf, sizeof(readBuf));
        mbedtls_sha256_update(&sha256_ctx, readBuf, bytesRead);
        totalRead += bytesRead;
    }
    patchFile.close();

    uint8_t hash[32];
    mbedtls_sha256_finish(&sha256_ctx, hash);
    mbedtls_sha256_free(&sha256_ctx);

    // Convert hash to hex string
    char hashHex[65];
    for (int i = 0; i < 32; i++) {
        sprintf(hashHex + (i * 2), "%02x", hash[i]);
    }
    hashHex[64] = '\0';

    Serial.printf("[OTA-DELTA] Patch size: %zu bytes\n", totalRead);
    Serial.printf("[OTA-DELTA] Calculated SHA256: %s\n", hashHex);
    Serial.printf("[OTA-DELTA] Expected SHA256:   %s\n", g_otaDelta.patchSha256);

    // Compare (case-insensitive)
    if (strcasecmp(hashHex, g_otaDelta.patchSha256) != 0) {
        Serial.println("[OTA-DELTA] SHA256 MISMATCH - patch corrupted!");
        return false;
    }

    Serial.println("[OTA-DELTA] SHA256 verified OK");
    return true;
}

// Report OTA completion status to backend
// POST /api/ota/complete {"device_id":"JBNB0001","fw_version":"4.7","status":"success"}
static void otaReportComplete(const char* status) {
    Serial.printf("[OTA-DELTA] Reporting completion: %s\n", status);

    char jsonPayload[128];
    snprintf(jsonPayload, sizeof(jsonPayload),
             "{\"device_id\":\"%s\",\"fw_version\":\"%s\",\"status\":\"%s\"}",
             DEVICE_ID, g_otaDelta.targetVersion, status);

    size_t jsonLen = strlen(jsonPayload);

    char httpRequest[384];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        OTA_COMPLETE_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return;
    }

    delay(300);

    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        atSendRaw(httpRequest, httpLen);
        atWaitFor("+CIPSEND:", 10000);
        delay(1000);
    }

    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
}

// Apply the delta patch to create new firmware
// This is a simplified approach - for full bsdiff support, use esp_delta_ota component
// For now, we'll implement a direct binary patch application
static bool otaApplyPatch() {
    Serial.println("[OTA-DELTA] Applying patch...");

    // Get the running partition and next OTA partition
    const esp_partition_t* running = esp_ota_get_running_partition();
    const esp_partition_t* update = esp_ota_get_next_update_partition(NULL);

    if (!running || !update) {
        Serial.println("[OTA-DELTA] Cannot get partition info");
        return false;
    }

    Serial.printf("[OTA-DELTA] Running partition: %s at 0x%08lx\n",
                  running->label, running->address);
    Serial.printf("[OTA-DELTA] Update partition: %s at 0x%08lx\n",
                  update->label, update->address);

    // Open patch file
    File patchFile = SPIFFS.open(OTA_PATCH_FILE, "r");
    if (!patchFile) {
        Serial.println("[OTA-DELTA] Cannot open patch file");
        return false;
    }

    size_t patchSize = patchFile.size();
    Serial.printf("[OTA-DELTA] Patch file size: %zu bytes\n", patchSize);

    // Note: For a true delta update, we would need to:
    // 1. Read the current firmware from running partition
    // 2. Apply bsdiff patch algorithm
    // 3. Write result to update partition
    //
    // For simplicity in this implementation, we assume the "patch" is actually
    // a complete firmware image (full OTA). The backend can be configured to
    // send full images for initial deployment, then switch to delta patches
    // once the delta infrastructure is proven.
    //
    // To enable true delta updates, integrate esp_delta_ota component:
    // https://github.com/nickvuenen/esp_delta_ota

    // Begin OTA update
    esp_ota_handle_t ota_handle;
    esp_err_t err = esp_ota_begin(update, patchSize, &ota_handle);
    if (err != ESP_OK) {
        Serial.printf("[OTA-DELTA] esp_ota_begin failed: 0x%x\n", err);
        patchFile.close();
        return false;
    }

    // Write patch data to OTA partition
    uint8_t writeBuf[1024];
    size_t totalWritten = 0;

    while (patchFile.available()) {
        size_t bytesRead = patchFile.read(writeBuf, sizeof(writeBuf));

        err = esp_ota_write(ota_handle, writeBuf, bytesRead);
        if (err != ESP_OK) {
            Serial.printf("[OTA-DELTA] esp_ota_write failed at %zu: 0x%x\n", totalWritten, err);
            esp_ota_abort(ota_handle);
            patchFile.close();
            return false;
        }

        totalWritten += bytesRead;

        // Progress indicator every 10KB
        if (totalWritten % 10240 < 1024) {
            Serial.printf("[OTA-DELTA] Written: %zu / %zu bytes\n", totalWritten, patchSize);
        }

        // Feed watchdog during long write
        esp_task_wdt_reset();
    }

    patchFile.close();

    Serial.printf("[OTA-DELTA] Total written: %zu bytes\n", totalWritten);

    // Finalize OTA update
    err = esp_ota_end(ota_handle);
    if (err != ESP_OK) {
        Serial.printf("[OTA-DELTA] esp_ota_end failed: 0x%x\n", err);
        return false;
    }

    // Set boot partition
    err = esp_ota_set_boot_partition(update);
    if (err != ESP_OK) {
        Serial.printf("[OTA-DELTA] esp_ota_set_boot_partition failed: 0x%x\n", err);
        return false;
    }

    Serial.println("[OTA-DELTA] Patch applied successfully");
    Serial.printf("[OTA-DELTA] Next boot will use partition: %s\n", update->label);

    return true;
}

// Non-blocking OTA background handler - call from main loop
// Processes one step per call to avoid blocking probe capture
static void handleOtaDeltaBackground() {
    // Skip if WiFi AP OTA is in progress
    if (g_otaInProgress) return;

    // Skip if network not ready
    if (!g_networkReady) return;

    switch (g_otaDelta.state) {
        case OTA_DELTA_IDLE:
            // Check if OTA check was requested (from command or heartbeat)
            if (g_otaDelta.checkPending) {
                g_otaDelta.checkPending = false;
                g_otaDelta.state = OTA_DELTA_CHECKING;
                ledSetStatus(LED_STATUS_TRANSMITTING);  // CYAN during check
                Serial.println("[OTA-DELTA] Starting update check...");
            }
            break;

        case OTA_DELTA_CHECKING:
            // Perform update check
            if (otaCheckForUpdate()) {
                // Update available - initialize download
                if (!initSpiffs()) {
                    Serial.println("[OTA-DELTA] SPIFFS init failed, aborting");
                    otaClearState();
                    ledSetStatus(LED_STATUS_CONNECTED);
                    break;
                }

                g_otaDelta.chunksReceived = 0;
                g_otaDelta.chunkRetries = 0;
                g_otaDelta.lastChunkTime = millis();
                g_otaDelta.state = OTA_DELTA_DOWNLOADING;
                otaSaveState();

                Serial.println("[OTA-DELTA] Starting download...");
                ledSetStatus(LED_STATUS_TRANSMITTING);  // CYAN pulse during download
            } else {
                // No update or check failed
                g_otaDelta.state = OTA_DELTA_IDLE;
                ledSetStatus(LED_STATUS_CONNECTED);
            }
            break;

        case OTA_DELTA_DOWNLOADING:
            // Download one chunk per loop iteration (non-blocking)
            if (g_otaDelta.chunksReceived < g_otaDelta.totalChunks) {
                if (otaDownloadChunk(g_otaDelta.chunksReceived)) {
                    // Success - move to next chunk
                    g_otaDelta.chunksReceived++;
                    g_otaDelta.chunkRetries = 0;
                    g_otaDelta.lastChunkTime = millis();
                    otaSaveState();

                    // Brief LED flash to show progress
                    ledSetColor(COLOR_GREEN);
                    delay(50);
                    ledSetColor(COLOR_CYAN);
                } else {
                    // Failed - retry or abort
                    g_otaDelta.chunkRetries++;
                    Serial.printf("[OTA-DELTA] Chunk %d failed, retry %d/%d\n",
                                  g_otaDelta.chunksReceived,
                                  g_otaDelta.chunkRetries,
                                  OTA_MAX_CHUNK_RETRIES);

                    if (g_otaDelta.chunkRetries >= OTA_MAX_CHUNK_RETRIES) {
                        Serial.println("[OTA-DELTA] Too many retries, aborting OTA");
                        otaReportComplete("failed_download");
                        otaClearState();
                        ledSetStatus(LED_STATUS_CONNECTED);
                    }
                }
            } else {
                // All chunks downloaded - move to verification
                Serial.println("[OTA-DELTA] Download complete, verifying...");
                g_otaDelta.state = OTA_DELTA_VERIFYING;
                otaSaveState();
            }
            break;

        case OTA_DELTA_VERIFYING:
            // Verify the complete patch
            if (otaVerifyPatch()) {
                Serial.println("[OTA-DELTA] Verification passed, applying...");
                g_otaDelta.state = OTA_DELTA_APPLYING;
                otaSaveState();
                ledSetStatus(LED_STATUS_OTA_MODE);  // YELLOW during apply
            } else {
                Serial.println("[OTA-DELTA] Verification failed, aborting OTA");
                otaReportComplete("failed_verify");
                otaClearState();
                ledSetStatus(LED_STATUS_CONNECTED);
            }
            break;

        case OTA_DELTA_APPLYING:
            // Apply the patch to OTA partition
            // Disable watchdog during patch application (can take a while)
            esp_task_wdt_delete(NULL);

            if (otaApplyPatch()) {
                Serial.println("[OTA-DELTA] Patch applied successfully");
                g_otaDelta.state = OTA_DELTA_REBOOTING;
                otaSaveState();

                // Report success before reboot
                otaReportComplete("success");

                // Clean up patch file
                SPIFFS.remove(OTA_PATCH_FILE);

                Serial.println("[OTA-DELTA] Rebooting to new firmware...");
                delay(1000);
                ESP.restart();
            } else {
                Serial.println("[OTA-DELTA] Patch application failed");
                otaReportComplete("failed_apply");
                otaClearState();

                // Re-enable watchdog
                esp_task_wdt_add(NULL);
                ledSetStatus(LED_STATUS_CONNECTED);
            }
            break;

        case OTA_DELTA_REBOOTING:
            // Should not reach here - device reboots in APPLYING state
            ESP.restart();
            break;
    }
}

// Trigger OTA check (called from command handling or after heartbeat)
static void triggerOtaCheck() {
    if (g_otaDelta.state == OTA_DELTA_IDLE) {
        g_otaDelta.checkPending = true;
        Serial.println("[OTA-DELTA] OTA check scheduled");
    } else {
        Serial.printf("[OTA-DELTA] OTA already in progress (state=%d)\n", g_otaDelta.state);
    }
}

// =============================================================================
// OTA Update via WiFi AP Mode
// =============================================================================

// HTML page for OTA update
static const char* OTA_HTML = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>JamBox OTA Update</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; background: #1a1a2e; color: #eee; }
        h1 { color: #16c60c; }
        .container { max-width: 400px; margin: 0 auto; padding: 20px; background: #16213e; border-radius: 10px; }
        input[type="file"] { margin: 20px 0; }
        input[type="submit"] { background: #16c60c; color: #000; padding: 15px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; }
        input[type="submit"]:hover { background: #13a80a; }
        #progress { width: 100%; height: 30px; margin-top: 20px; display: none; }
        .status { margin-top: 20px; padding: 10px; border-radius: 5px; }
        .success { background: #16c60c; color: #000; }
        .error { background: #f03a47; }
    </style>
</head>
<body>
    <div class="container">
        <h1>JamBox OTA Update</h1>
        <p>Device ID: %DEVICE_ID%</p>
        <form method="POST" action="/update" enctype="multipart/form-data" id="upload_form">
            <input type="file" name="firmware" accept=".bin" required>
            <br><br>
            <input type="submit" value="Upload Firmware">
        </form>
        <progress id="progress" max="100" value="0"></progress>
        <div id="status" class="status" style="display:none;"></div>
    </div>
    <script>
        var form = document.getElementById('upload_form');
        var progress = document.getElementById('progress');
        var status = document.getElementById('status');
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            var data = new FormData(form);
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/update', true);
            progress.style.display = 'block';
            xhr.upload.addEventListener('progress', function(evt) {
                if (evt.lengthComputable) {
                    progress.value = Math.round((evt.loaded / evt.total) * 100);
                }
            });
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    status.style.display = 'block';
                    if (xhr.status == 200) {
                        status.className = 'status success';
                        status.innerHTML = 'Update successful! Rebooting...';
                        setTimeout(function() { location.reload(); }, 5000);
                    } else {
                        status.className = 'status error';
                        status.innerHTML = 'Update failed: ' + xhr.responseText;
                    }
                }
            };
            xhr.send(data);
        });
    </script>
</body>
</html>
)rawliteral";

static void handleOtaRoot() {
    String html = OTA_HTML;
    html.replace("%DEVICE_ID%", DEVICE_ID);
    g_otaServer->send(200, "text/html", html);
}

static void handleOtaUpdate() {
    g_otaServer->sendHeader("Connection", "close");
    if (Update.hasError()) {
        g_otaServer->send(500, "text/plain", "Update failed");
    } else {
        g_otaServer->send(200, "text/plain", "Update successful");
        delay(1000);
        ESP.restart();
    }
}

static void handleOtaUpload() {
    HTTPUpload& upload = g_otaServer->upload();

    if (upload.status == UPLOAD_FILE_START) {
        Serial.printf("[OTA] Update start: %s\n", upload.filename.c_str());
        if (!Update.begin(UPDATE_SIZE_UNKNOWN)) {
            Update.printError(Serial);
        }
    } else if (upload.status == UPLOAD_FILE_WRITE) {
        if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {
            Update.printError(Serial);
        }
    } else if (upload.status == UPLOAD_FILE_END) {
        if (Update.end(true)) {
            Serial.printf("[OTA] Update success: %u bytes\n", upload.totalSize);
        } else {
            Update.printError(Serial);
        }
    }
}

static void startOtaMode() {
    Serial.println("[OTA] Entering OTA update mode...");
    ledSetStatus(LED_STATUS_OTA_MODE);
    g_otaInProgress = true;

    // Disable watchdog during OTA (long operation)
    esp_task_wdt_delete(NULL);
    Serial.println("[OTA] Watchdog disabled for OTA");

    // Stop probe capture
    stopProbeCapture();

    // Stop WiFi promiscuous mode and switch to AP mode
    esp_wifi_set_promiscuous(false);
    WiFi.mode(WIFI_AP);
    WiFi.softAP(OTA_AP_SSID, OTA_AP_PASSWORD);

    IPAddress ip = WiFi.softAPIP();
    Serial.printf("[OTA] AP Started - SSID: %s, Password: %s\n", OTA_AP_SSID, OTA_AP_PASSWORD);
    Serial.printf("[OTA] Connect and browse to http://%s\n", ip.toString().c_str());

    // Start web server for OTA
    g_otaServer = new WebServer(80);
    g_otaServer->on("/", HTTP_GET, handleOtaRoot);
    g_otaServer->on("/update", HTTP_POST, handleOtaUpdate, handleOtaUpload);
    g_otaServer->begin();

    Serial.println("[OTA] Web server started. Waiting for firmware upload...");
}

static void stopOtaMode() {
    Serial.println("[OTA] Exiting OTA mode...");

    if (g_otaServer) {
        g_otaServer->stop();
        delete g_otaServer;
        g_otaServer = nullptr;
    }

    WiFi.softAPdisconnect(true);
    g_otaInProgress = false;
    g_otaRequested = false;

    // Re-enable watchdog timer
    esp_task_wdt_add(NULL);
    Serial.println("[OTA] Watchdog re-enabled");

    // Restart probe capture
    startProbeCapture();

    // Restore network status LED
    if (g_networkReady) {
        ledSetStatus(g_lastSendSuccess ? LED_STATUS_CONNECTED : LED_STATUS_SEND_FAILED);
    } else {
        ledSetStatus(LED_STATUS_SEARCHING);
    }
}

// =============================================================================
// Reporting Logic
// =============================================================================

// Get current counts and reset
// overflowCount: combined WiFi+BLE overflow (indicates data quality issue)
static void getAndResetCounts(uint32_t* impressions, uint32_t* unique,
                               int* probeRssiAvg, int* probeRssiMin, int* probeRssiMax,
                               uint32_t* dwell_0_1, uint32_t* dwell_1_5,
                               uint32_t* dwell_5_10, uint32_t* dwell_10plus,
                               uint32_t* rssi_immediate, uint32_t* rssi_near,
                               uint32_t* rssi_far, uint32_t* rssi_remote,
                               uint32_t* bleImpressions, uint32_t* bleUnique,
                               uint32_t* bleApple, uint32_t* bleOther,
                               int* bleRssiAvg, uint16_t* overflowCount) {
    // Get WiFi probe counts
    portENTER_CRITICAL(&g_probeMux);
    *impressions = g_totalProbes;
    *unique = g_uniqueMacCount;
    uint16_t wifiOverflow = g_uniqueOverflow;  // Capture before reset
    // Calculate probe RSSI stats
    if (g_probeRssiCount > 0) {
        *probeRssiAvg = g_probeRssiSum / (int32_t)g_probeRssiCount;
        *probeRssiMin = g_probeRssiMin;
        *probeRssiMax = g_probeRssiMax;
    } else {
        *probeRssiAvg = 0;
        *probeRssiMin = 0;
        *probeRssiMax = 0;
    }
    // Calculate dwell time buckets using parallel arrays
    // For each MAC, calculate how many minutes they were seen (lastSeen - firstSeen + 1)
    // Bucket thresholds are configurable via remote config
    *dwell_0_1 = 0;
    *dwell_1_5 = 0;
    *dwell_5_10 = 0;
    *dwell_10plus = 0;
    for (uint16_t i = 0; i < g_dwellCount; i++) {
        uint16_t firstMin = g_dwellFirstSeen[i];
        uint16_t lastMin = g_dwellLastSeen[i];
        // Handle minute wrap-around (unlikely in 5-min interval but safe)
        int duration = (lastMin >= firstMin) ? (lastMin - firstMin + 1) : 1;
        // Bucket the duration using configurable thresholds
        if (duration <= g_dwellShortThreshold) {
            (*dwell_0_1)++;      // Quick Glance
        } else if (duration <= g_dwellMediumThreshold) {
            (*dwell_1_5)++;      // Browsing
        } else if (duration <= g_dwellLongThreshold) {
            (*dwell_5_10)++;     // Shopping
        } else {
            (*dwell_10plus)++;   // Loyal Customer
        }
    }
    // Copy RSSI zone counts
    *rssi_immediate = g_rssi_immediate;
    *rssi_near = g_rssi_near;
    *rssi_far = g_rssi_far;
    *rssi_remote = g_rssi_remote;
    // Reset WiFi counters (fixed arrays - just reset counts, no deallocation)
    g_totalProbes = 0;
    g_filteredStatic = 0;
    g_probeRssiSum = 0;
    g_probeRssiMin = 0;
    g_probeRssiMax = -999;
    g_probeRssiCount = 0;
    g_rssi_immediate = 0;
    g_rssi_near = 0;
    g_rssi_far = 0;
    g_rssi_remote = 0;
    g_uniqueMacCount = 0;   // Reset array count (no heap ops)
    g_uniqueAPCount = 0;    // Reset array count (no heap ops)
    g_dwellCount = 0;       // Reset dwell array count (no heap ops)
    g_uniqueOverflow = 0;   // Reset overflow counter for next period
    portEXIT_CRITICAL(&g_probeMux);

    // Get BLE counts (Apple vs Other)
    portENTER_CRITICAL(&g_bleMux);
    *bleImpressions = g_bleImpressions;
    *bleUnique = g_bleUniqueMacCount;
    *bleApple = g_bleAppleCount;
    *bleOther = g_bleOtherCount;
    uint16_t bleOverflow = g_bleOverflow;  // Capture before reset
    if (g_bleRssiCount > 0) {
        *bleRssiAvg = g_bleRssiSum / (int32_t)g_bleRssiCount;
    } else {
        *bleRssiAvg = 0;
    }
    // Reset BLE counters (fixed arrays - just reset count, no heap ops)
    g_bleImpressions = 0;
    g_bleAppleCount = 0;
    g_bleOtherCount = 0;
    g_bleRssiSum = 0;
    g_bleRssiCount = 0;
    g_bleUniqueMacCount = 0;  // Reset array count (no heap ops)
    g_bleOverflow = 0;        // Reset overflow counter for next period
    portEXIT_CRITICAL(&g_bleMux);

    // Combined overflow count (WiFi + BLE)
    *overflowCount = wifiOverflow + bleOverflow;
}

// Report counts to backend
static void reportCounts() {
    uint32_t impressions, unique;
    int probeRssiAvg, probeRssiMin, probeRssiMax;
    uint32_t dwell_0_1, dwell_1_5, dwell_5_10, dwell_10plus;
    uint32_t rssi_immediate, rssi_near, rssi_far, rssi_remote;
    uint32_t bleImpressions, bleUnique, bleApple, bleOther;
    int bleRssiAvg;
    uint16_t overflowCount;

    getAndResetCounts(&impressions, &unique,
                      &probeRssiAvg, &probeRssiMin, &probeRssiMax,
                      &dwell_0_1, &dwell_1_5, &dwell_5_10, &dwell_10plus,
                      &rssi_immediate, &rssi_near, &rssi_far, &rssi_remote,
                      &bleImpressions, &bleUnique, &bleApple, &bleOther, &bleRssiAvg,
                      &overflowCount);

    // Get current cellular signal
    g_cellRssi = getSignalQuality();

    // Capture current time for age calculation if this reading gets cached
    uint32_t readingMillis = millis();

    // Generate ISO 8601 timestamp
    uint32_t epochTime = g_bootTimestamp + (readingMillis / 1000);
    char timestamp[25];
    time_t rawtime = (time_t)epochTime;
    struct tm* timeinfo = gmtime(&rawtime);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%dT%H:%M:%SZ", timeinfo);

    Serial.printf("[REPORT] WiFi: %lu probes, %lu unique (overflow: %u)\n", impressions, unique, overflowCount);
    Serial.printf("[REPORT] BLE: %lu ads, %lu unique (Apple:%lu Other:%lu)\n",
                  bleImpressions, bleUnique, bleApple, bleOther);
    Serial.printf("[REPORT] Dwell: 0-1min:%lu 1-5min:%lu 5-10min:%lu 10+min:%lu\n",
                  dwell_0_1, dwell_1_5, dwell_5_10, dwell_10plus);
    Serial.printf("[REPORT] RSSI zones: immediate:%lu near:%lu far:%lu remote:%lu\n",
                  rssi_immediate, rssi_near, rssi_far, rssi_remote);
    Serial.printf("[REPORT] Probe RSSI: avg=%d min=%d max=%d, BLE RSSI: avg=%d, Cell: %d dBm\n",
                  probeRssiAvg, probeRssiMin, probeRssiMax, bleRssiAvg, g_cellRssi);

    // Try to send cached readings first (up to 5 per report cycle to avoid timeout)
    int cachedSent = 0;
    CachedReading cached;
    while (cachedSent < 5 && popCachedReading(&cached)) {
        // Calculate age in seconds: how long since this reading was cached
        uint32_t ageSeconds = (millis() - cached.cachedAtMillis) / 1000;
        Serial.printf("[REPORT] Retrying cached reading (%d remaining, age=%lu sec)...\n", g_cacheCount, ageSeconds);
        if (sendReading(cached.timestamp,
                        cached.impressions,
                        cached.unique,
                        cached.probeRssiAvg,
                        cached.probeRssiMin,
                        cached.probeRssiMax,
                        cached.cellRssi,
                        cached.dwell_0_1,
                        cached.dwell_1_5,
                        cached.dwell_5_10,
                        cached.dwell_10plus,
                        cached.rssi_immediate,
                        cached.rssi_near,
                        cached.rssi_far,
                        cached.rssi_remote,
                        cached.bleImpressions,
                        cached.bleUnique,
                        cached.bleApple,
                        cached.bleOther,
                        cached.bleRssiAvg,
                        cached.overflowCount,
                        ageSeconds)) {
            cachedSent++;
            Serial.println("[REPORT] Cached reading sent successfully");
        } else {
            // Re-cache this reading at the front (it failed again)
            cacheReading(cached);
            break;  // Stop trying if network is down
        }
    }

    // Send current reading (age=0 for live readings)
    if (!sendReading(timestamp, impressions, unique,
                     probeRssiAvg, probeRssiMin, probeRssiMax, g_cellRssi,
                     dwell_0_1, dwell_1_5, dwell_5_10, dwell_10plus,
                     rssi_immediate, rssi_near, rssi_far, rssi_remote,
                     bleImpressions, bleUnique, bleApple, bleOther, bleRssiAvg,
                     overflowCount, 0)) {
        // Cache for retry using circular buffer
        CachedReading newReading;
        newReading.valid = true;
        strncpy(newReading.timestamp, timestamp, sizeof(newReading.timestamp));
        newReading.cachedAtMillis = readingMillis;   // When this reading was created
        newReading.overflowCount = overflowCount;    // Preserve overflow count for this period
        newReading.impressions = impressions;
        newReading.unique = unique;
        newReading.probeRssiAvg = probeRssiAvg;
        newReading.probeRssiMin = probeRssiMin;
        newReading.probeRssiMax = probeRssiMax;
        newReading.cellRssi = g_cellRssi;
        newReading.dwell_0_1 = dwell_0_1;
        newReading.dwell_1_5 = dwell_1_5;
        newReading.dwell_5_10 = dwell_5_10;
        newReading.dwell_10plus = dwell_10plus;
        newReading.rssi_immediate = rssi_immediate;
        newReading.rssi_near = rssi_near;
        newReading.rssi_far = rssi_far;
        newReading.rssi_remote = rssi_remote;
        newReading.bleImpressions = bleImpressions;
        newReading.bleUnique = bleUnique;
        newReading.bleApple = bleApple;
        newReading.bleOther = bleOther;
        newReading.bleRssiAvg = bleRssiAvg;
        cacheReading(newReading);

        // Try to re-initialize network for next time
        g_networkReady = false;
    }
}

// =============================================================================
// WiFi Geolocation Functions
// =============================================================================

// Perform WiFi scan to collect nearby access points for geolocation
static void performGeolocationScan() {
    Serial.println("[GEO] Scanning for WiFi networks...");
    g_wifiNetworkCount = 0;

    // Temporarily disable promiscuous mode for scanning
    esp_wifi_set_promiscuous(false);

    // Set WiFi to station mode for scanning
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    delay(100);

    // Perform scan (blocking)
    int numNetworks = WiFi.scanNetworks(false, false, false, 300);

    if (numNetworks < 0) {
        Serial.println("[GEO] WiFi scan failed");
        return;
    }

    Serial.printf("[GEO] Found %d networks\n", numNetworks);

    // Store top networks by signal strength (already sorted by RSSI)
    int count = min(numNetworks, MAX_WIFI_NETWORKS);
    for (int i = 0; i < count; i++) {
        // Get BSSID as string
        snprintf(g_wifiNetworks[i].bssid, sizeof(g_wifiNetworks[i].bssid),
                 "%02X:%02X:%02X:%02X:%02X:%02X",
                 WiFi.BSSID(i)[0], WiFi.BSSID(i)[1], WiFi.BSSID(i)[2],
                 WiFi.BSSID(i)[3], WiFi.BSSID(i)[4], WiFi.BSSID(i)[5]);
        g_wifiNetworks[i].rssi = WiFi.RSSI(i);
        g_wifiNetworks[i].channel = WiFi.channel(i);

        Serial.printf("[GEO]   %d: %s RSSI:%d CH:%d\n",
                      i + 1, g_wifiNetworks[i].bssid,
                      g_wifiNetworks[i].rssi, g_wifiNetworks[i].channel);
    }
    g_wifiNetworkCount = count;

    // Clear scan results to free memory
    WiFi.scanDelete();
}

// Send geolocation data to backend
static bool sendGeolocationData() {
    if (g_wifiNetworkCount == 0) {
        Serial.println("[GEO] No WiFi networks to send");
        return false;
    }

    Serial.printf("[GEO] Sending %d WiFi networks for geolocation...\n", g_wifiNetworkCount);

    // Build JSON payload
    // Format: {"d":"JBNB0001","wifi":[{"bssid":"AA:BB:CC:DD:EE:FF","rssi":-65,"ch":6},...]}
    char jsonPayload[512];
    int offset = snprintf(jsonPayload, sizeof(jsonPayload), "{\"d\":\"%s\",\"wifi\":[", DEVICE_ID);

    for (int i = 0; i < g_wifiNetworkCount && offset < (int)sizeof(jsonPayload) - 100; i++) {
        if (i > 0) {
            jsonPayload[offset++] = ',';
        }
        offset += snprintf(jsonPayload + offset, sizeof(jsonPayload) - offset,
                           "{\"bssid\":\"%s\",\"rssi\":%d,\"ch\":%d}",
                           g_wifiNetworks[i].bssid,
                           g_wifiNetworks[i].rssi,
                           g_wifiNetworks[i].channel);
    }
    offset += snprintf(jsonPayload + offset, sizeof(jsonPayload) - offset, "]}");

    size_t jsonLen = strlen(jsonPayload);

    // Build HTTP request
    char httpRequest[768];
    int httpLen = snprintf(httpRequest, sizeof(httpRequest),
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Authorization: Bearer %s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        GEOLOCATION_PATH, BACKEND_HOST, BACKEND_PORT,
        AUTH_TOKEN, jsonLen, jsonPayload);

    // Open TCP connection
    char tcpOpenCmd[128];
    snprintf(tcpOpenCmd, sizeof(tcpOpenCmd),
             "AT+CIPOPEN=0,\"TCP\",\"%s\",%d", BACKEND_HOST, BACKEND_PORT);

    Serial.printf("[GEO] Connecting to %s:%d\n", BACKEND_HOST, BACKEND_PORT);

    if (!atSendCommand(tcpOpenCmd, "+CIPOPEN: 0,0", TCP_CONNECT_TIMEOUT_MS)) {
        Serial.println("[GEO] TCP connect failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    Serial.println("[GEO] Connected");
    delay(500);

    // Send data
    char sendCmd[32];
    snprintf(sendCmd, sizeof(sendCmd), "AT+CIPSEND=0,%d", httpLen);

    if (!atSendCommand(sendCmd, ">", AT_COMMAND_TIMEOUT_MS)) {
        Serial.println("[GEO] CIPSEND prompt failed");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Send HTTP request data
    atSendRaw(httpRequest, httpLen);

    // Wait for send confirmation
    if (!atWaitFor("+CIPSEND:", 15000)) {
        Serial.println("[GEO] Send confirmation timeout");
        atSendCommand("AT+CIPCLOSE=0", "OK", 5000);
        return false;
    }

    // Wait for HTTP response
    delay(2000);

    // Read response data
    atClearBuffer();
    uint32_t readStart = millis();
    while ((millis() - readStart) < 5000) {
        while (ModemSerial.available() && g_atBufferLen < sizeof(g_atBuffer) - 1) {
            char c = ModemSerial.read();
            g_atBuffer[g_atBufferLen++] = c;
        }
        delay(100);
    }
    g_atBuffer[g_atBufferLen] = '\0';

    if (g_atBufferLen > 0) {
        Serial.printf("[GEO] Response: %s\n", g_atBuffer);
    }

    // Check for HTTP success
    bool success = (strstr(g_atBuffer, "200") != NULL ||
                    strstr(g_atBuffer, "201") != NULL);

    // Close TCP connection
    atSendCommand("AT+CIPCLOSE=0", "OK", 5000);

    if (success) {
        Serial.println("[GEO] Geolocation sent successfully");
    } else {
        Serial.println("[GEO] Geolocation send failed");
    }

    return success;
}

// =============================================================================
// Button Handling
// =============================================================================

static bool g_buttonPressed = false;
static uint32_t g_buttonPressTime = 0;

static void checkButton() {
    bool buttonState = (digitalRead(BUTTON_PIN) == LOW);

    if (buttonState && !g_buttonPressed) {
        // Button just pressed
        g_buttonPressed = true;
        g_buttonPressTime = millis();
        ledSetStatus(LED_STATUS_BUTTON_ACK);
    } else if (!buttonState && g_buttonPressed) {
        // Button released
        uint32_t pressDuration = millis() - g_buttonPressTime;
        g_buttonPressed = false;

        if (pressDuration > 3000) {
            // Long press (>3 seconds) - enter OTA mode
            Serial.println("[BTN] Long press - entering OTA mode");
            g_otaRequested = true;
        } else if (pressDuration > 100) {
            // Short press - send data packet immediately
            Serial.println("[BTN] Short press - sending data now");
            g_forceSendRequested = true;
        }
    }
}

static void checkResetButton() {
    static bool resetButtonPressed = false;
    static uint32_t resetButtonPressTime = 0;

    bool buttonState = (digitalRead(RESET_BUTTON_PIN) == LOW);

    if (buttonState && !resetButtonPressed) {
        resetButtonPressed = true;
        resetButtonPressTime = millis();
        ledSetStatus(LED_STATUS_BUTTON_ACK);
    } else if (!buttonState && resetButtonPressed) {
        uint32_t pressDuration = millis() - resetButtonPressTime;
        resetButtonPressed = false;

        if (pressDuration > 100) {
            Serial.println("[BTN] Reset button - rebooting...");
            delay(500);
            ESP.restart();
        }
    }
}

// =============================================================================
// Main Setup and Loop
// =============================================================================

void setup() {
    // Initialize USB Serial
    Serial.begin(115200);
    delay(2000);  // Wait for USB CDC

    Serial.println();
    Serial.println("========================================");
    Serial.printf("  NB-IoT JamBox Probe Counter v%s\n", FIRMWARE_VERSION);
    Serial.printf("  Device ID: %s\n", DEVICE_ID);
    Serial.printf("  Report interval: %lu minutes\n", REPORT_INTERVAL_MS / 60000);
    Serial.println("  Channel hopping: 1, 6, 11 (3s)");
    Serial.println("  Remote config: enabled");
    Serial.println("========================================");
    Serial.println();
    Serial.println("Default Thresholds (overridden by remote config):");
    Serial.printf("  RSSI: immediate=%d, near=%d, far=%d dBm\n",
                  g_rssiImmediateThreshold, g_rssiNearThreshold, g_rssiFarThreshold);
    Serial.printf("  Dwell: short=%u, medium=%u, long=%u min\n",
                  g_dwellShortThreshold, g_dwellMediumThreshold, g_dwellLongThreshold);
    Serial.println("========================================");
    Serial.println();
    Serial.println("LED Status:");
    Serial.println("  PURPLE      = Booting");
    Serial.println("  RED (slow)  = Searching for network");
    Serial.println("  RED (fast)  = Error");
    Serial.println("  GREEN       = Connected, counting");
    Serial.println("  CYAN        = Transmitting");
    Serial.println("  GREEN       = Send successful");
    Serial.println("  BLUE        = Send failed");
    Serial.println("  YELLOW      = OTA mode");
    Serial.println();
    Serial.println("Buttons:");
    Serial.println("  Main short press  = Send data now");
    Serial.println("  Main long (3s)    = OTA mode");
    Serial.println("  Side button       = Reboot");
    Serial.println();

    // Initialize LED
    ledInit();
    ledSetStatus(LED_STATUS_BOOTING);

    // Initialize buttons
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);

    // Initialize modem serial
    ModemSerial.begin(MODEM_BAUD, SERIAL_8N1, MODEM_RX_PIN, MODEM_TX_PIN);
    delay(1000);

    // Initialize SPIFFS for OTA patch storage
    Serial.println("[INIT] Initializing SPIFFS...");
    initSpiffs();

    // Load OTA state from NVS (for recovery after crash/power loss)
    Serial.println("[INIT] Loading OTA state from NVS...");
    otaLoadState();

    // If OTA was in progress before reboot, handle recovery
    if (g_otaDelta.state != OTA_DELTA_IDLE) {
        if (g_otaDelta.state == OTA_DELTA_REBOOTING) {
            // We just rebooted after successful OTA - clear state
            Serial.println("[INIT] OTA complete from previous boot, clearing state");
            otaClearState();
        } else if (g_otaDelta.state == OTA_DELTA_DOWNLOADING &&
                   g_otaDelta.chunksReceived > 0) {
            // Resume download from where we left off
            Serial.printf("[INIT] Resuming OTA download at chunk %d/%d\n",
                          g_otaDelta.chunksReceived, g_otaDelta.totalChunks);
        } else {
            // Other interrupted state - restart OTA process
            Serial.printf("[INIT] OTA interrupted in state %d, restarting\n", g_otaDelta.state);
            otaClearState();
        }
    }

    // Set boot timestamp (would use NTP in production)
    g_bootTimestamp = 1769587200;  // 2026-01-28T08:00:00Z - fallback until server sync

    // Perform WiFi geolocation scan FIRST (fast, before network init)
    Serial.println("[INIT] Performing geolocation scan...");
    performGeolocationScan();

    // Initialize network (can take 1-2 minutes for NB-IoT)
    Serial.println("[INIT] Initializing NB-IoT network...");
    if (!initializeNetwork()) {
        Serial.println("[INIT] Network init failed - will retry later");
        ledSetStatus(LED_STATUS_SEARCHING);
    }

    // Send geolocation data if we have network and found WiFi networks
    if (g_networkReady && g_wifiNetworkCount > 0) {
        Serial.println("[INIT] Sending geolocation data...");
        sendGeolocationData();
        g_geolocationPending = false;
    } else if (g_wifiNetworkCount == 0) {
        Serial.println("[INIT] No WiFi networks found for geolocation");
        g_geolocationPending = false;
    } else {
        Serial.println("[INIT] Network not ready, will send geolocation when connected");
        g_geolocationPending = true;
    }

    // Send initial heartbeat at boot
    if (g_networkReady) {
        Serial.println("[INIT] Sending initial heartbeat...");
        sendHeartbeat();
    }
    g_lastHeartbeatTime = millis();

    // Start probe capture
    Serial.println("[INIT] Starting probe capture...");
    startProbeCapture();

    // Initialize BLE for device type detection
    Serial.println("[INIT] Initializing BLE scanning...");
    initBle();

    // Initialize timing
    g_lastReportTime = millis();
    g_lastRadioSwitch = millis();  // Initialize radio time-slicing

    // Initialize watchdog timer - reboot if no feed for 5 minutes
    // This provides self-healing if the device gets stuck
    esp_task_wdt_init(300, true);  // 300 seconds (5 minutes), panic on timeout
    esp_task_wdt_add(NULL);        // Add current task (loop) to watchdog
    Serial.println("[INIT] Watchdog timer initialized (5 min timeout)");

    Serial.println("[INIT] Initialization complete");
    Serial.println("[INIT] Monitoring for WiFi probes and BLE advertisements...");
    Serial.println();
}

void loop() {
    // Feed the watchdog at start of each loop iteration
    esp_task_wdt_reset();

    uint32_t now = millis();

    // Update LED animation
    ledUpdate();

    // Update radio mode (WiFi/BLE time-slicing) - only when not in OTA mode
    if (!g_otaInProgress) {
        updateRadioMode();
    }

    // Check buttons
    checkButton();
    checkResetButton();

    // Handle OTA mode
    if (g_otaRequested && !g_otaInProgress) {
        startOtaMode();
    }

    if (g_otaInProgress) {
        // In WiFi AP OTA mode - just handle web server
        if (g_otaServer) {
            g_otaServer->handleClient();
        }

        // Timeout check
        static uint32_t otaStartTime = 0;
        if (otaStartTime == 0) {
            otaStartTime = now;
        }
        if ((now - otaStartTime) > OTA_TIMEOUT_MS) {
            Serial.println("[OTA] Timeout - exiting OTA mode");
            otaStartTime = 0;
            stopOtaMode();
        }
        return;  // Skip normal loop processing during WiFi AP OTA
    }

    // Handle delta OTA background processing (non-blocking)
    // This downloads one chunk per call when OTA is in progress
    handleOtaDeltaBackground();

    // Check if report interval has elapsed OR force send requested
    if ((now - g_lastReportTime) >= REPORT_INTERVAL_MS || g_forceSendRequested) {
        g_lastReportTime = now;
        g_forceSendRequested = false;

        Serial.println("\n[LOOP] Sending report...");

        // Temporarily stop scanning during transmission
        if (g_radioMode == RADIO_WIFI) {
            stopProbeCapture();
        } else {
            stopBleScan();
        }

        // Ensure network is ready
        if (!g_networkReady) {
            Serial.println("[LOOP] Re-initializing network...");
            initializeNetwork();
        }

        // Handle pending geolocation (from boot or remote command)
        if (g_networkReady && g_geolocationPending) {
            Serial.println("[LOOP] Processing geolocation request...");
            // Perform fresh WiFi scan (in case this was a remote command)
            performGeolocationScan();
            if (g_wifiNetworkCount > 0) {
                if (sendGeolocationData()) {
                    g_geolocationPending = false;
                    Serial.println("[LOOP] Geolocation sent successfully");
                }
            } else {
                Serial.println("[LOOP] No WiFi networks found for geolocation");
                g_geolocationPending = false;  // Clear to avoid infinite retries
            }
            // Note: probe capture will be restarted at end of report cycle
        }

        // Handle pending config fetch (v5.4 - remote configuration)
        if (g_networkReady && g_configFetchPending) {
            Serial.println("[LOOP] Processing config fetch...");
            if (fetchAndApplyConfig()) {
                g_configFetchPending = false;
                Serial.println("[LOOP] Config fetch successful");
            } else {
                Serial.println("[LOOP] Config fetch failed, will retry later");
                g_configFetchPending = false;  // Clear to avoid repeated failures
            }
        }

        // Send report
        reportCounts();

        // Resume scanning (always start in WiFi mode after report)
        g_radioMode = RADIO_WIFI;
        g_lastRadioSwitch = millis();
        startProbeCapture();

        Serial.println("[LOOP] Resuming probe/BLE capture\n");
    }

    // Daily heartbeat (every 24 hours)
    if ((now - g_lastHeartbeatTime) >= HEARTBEAT_INTERVAL_MS) {
        g_lastHeartbeatTime = now;
        if (g_networkReady) {
            Serial.println("[LOOP] Sending daily heartbeat...");
            sendHeartbeat();
        }
    }

    // Periodic status (every 60 seconds)
    static uint32_t lastStatus = 0;
    if ((now - lastStatus) >= 60000) {
        lastStatus = now;

        uint32_t probes, unique, filtered;
        int probeRssiAvg = 0;
        portENTER_CRITICAL(&g_probeMux);
        probes = g_totalProbes;
        unique = g_uniqueMacCount;
        filtered = g_filteredStatic;
        if (g_probeRssiCount > 0) {
            probeRssiAvg = g_probeRssiSum / (int32_t)g_probeRssiCount;
        }
        portEXIT_CRITICAL(&g_probeMux);

        uint32_t bleAds, bleUniq, bleApple, bleOther;
        portENTER_CRITICAL(&g_bleMux);
        bleAds = g_bleImpressions;
        bleUniq = g_bleUniqueMacCount;
        bleApple = g_bleAppleCount;
        bleOther = g_bleOtherCount;
        portEXIT_CRITICAL(&g_bleMux);

        uint32_t nextReport = (REPORT_INTERVAL_MS - (now - g_lastReportTime)) / 1000;
        const char* radioStr = (g_radioMode == RADIO_WIFI) ? "WiFi" : "BLE";
        Serial.printf("[STATUS] %s CH:%d WiFi:%lu/%lu BLE:%lu/%lu(Apple:%lu Other:%lu) Filt:%lu Next:%lu sec\n",
                      radioStr, WIFI_CHANNELS[g_currentChannelIndex],
                      probes, unique, bleAds, bleUniq, bleApple, bleOther,
                      filtered, nextReport);

        // Heap monitoring for long-term reliability tracking
        Serial.printf("[HEAP] Free: %u, Min: %u, MaxBlock: %u\n",
                      ESP.getFreeHeap(),
                      ESP.getMinFreeHeap(),
                      ESP.getMaxAllocHeap());
    }

    // Small delay to yield to other tasks
    delay(10);
}
